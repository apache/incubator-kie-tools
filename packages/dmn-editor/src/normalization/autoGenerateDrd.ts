/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { generateUuid } from "@kie-tools/boxed-expression-component/dist/api";
import { ExternalModelsIndex } from "../DmnEditor";
import { computeDiagramData } from "../store/computed/computeDiagramData";
import { State } from "../store/Store";
import { MIN_NODE_SIZES } from "../diagram/nodes/DefaultSizes";
import { getNodeTypeFromDmnObject } from "../diagram/maths/DmnMaths";
import { DMN15__tDefinitions, DMNDI15__DMNShape } from "@kie-tools/dmn-marshaller/dist/schemas/dmn-1_5/ts-gen/types";
import { DmnLatestModel } from "@kie-tools/dmn-marshaller";
import { parseXmlHref } from "../xml/xmlHrefs";
import { computeExternalModelsByType } from "../store/computed/computeExternalModelsByType";
import { computeIndexedDrd } from "../store/computed/computeIndexes";
import { getDefaultDrdName } from "../mutations/addOrGetDrd";
import { addShape } from "../mutations/addShape";

export async function autoGenerateDrd(
  model: State["dmn"]["model"],
  externalModelsByNamespace: ExternalModelsIndex | undefined,
  diagram: State["diagram"]
) {
  // We assume the drg elements exist
  const drgElements = model.definitions.drgElement ?? [];
  const diagramElement: ({ __$$element: "dmndi:DMNShape" } & DMNDI15__DMNShape)[] = [];

  // generate shape for drgElementsWithoutVisualRepresentationOnCurrentDrd
  drgElements.forEach((drgElement) => {
    // addShape({
    //   "definitions": model.definitions,
    //   "drdIndex": 0,
    // })

    diagramElement.push({
      __$$element: "dmndi:DMNShape",
      "@_id": generateUuid(),
      "@_dmnElementRef": drgElement["@_id"]!,
      "dc:Bounds": {
        "@_x": 0,
        "@_y": 0,
        ...MIN_NODE_SIZES[getNodeTypeFromDmnObject(drgElement) ?? "node_unknown"]({
          snapGrid: {
            isEnabled: true,
            x: 20,
            y: 20,
          },
          isAlternativeInputDataShape: false,
        }),
      },
    });
  });

  const definedNamespaces = new Map(
    Object.keys(model.definitions)
      .filter((keys: keyof DMN15__tDefinitions) => String(keys).startsWith("@_xmlns:"))
      .map((xmlnsKey: keyof DMN15__tDefinitions) => [model.definitions[xmlnsKey], xmlnsKey.split("@_xmlns:")[1]])
  );

  const externalModelTypesByNamespace = computeExternalModelsByType(
    model.definitions.import,
    externalModelsByNamespace
  );
  const indexedDrd = computeIndexedDrd(model.definitions["@_namespace"], model.definitions, 0);
  const { nodesById, drgEdges } = computeDiagramData(
    diagram,
    model.definitions,
    externalModelTypesByNamespace,
    indexedDrd,
    false
  );

  // Create a set with missing external nodes
  const missingNodesHref = drgEdges.reduce((acc, drgEdge) => {
    if (!nodesById.has(drgEdge.sourceId)) {
      acc.add(drgEdge.sourceId);
    }
    if (!nodesById.has(drgEdge.targetId)) {
      acc.add(drgEdge.targetId);
    }
    return acc;
  }, new Set<string>());

  const externalDMNDiagramElement: ({ __$$element: "dmndi:DMNShape" } & DMNDI15__DMNShape)[] = [];

  // generate external nodes
  missingNodesHref.forEach((href) => {
    const { namespace, id } = parseXmlHref(href);
    if (namespace) {
      const externalModel = externalModelsByNamespace?.[namespace];
      if (externalModel && (externalModel.model as DmnLatestModel).definitions) {
        const drgElements = (externalModel.model as DmnLatestModel).definitions.drgElement;
        const drgElement = drgElements?.filter((drgElement) => drgElement["@_id"] === id);
        externalDMNDiagramElement.push({
          __$$element: "dmndi:DMNShape",
          "@_id": generateUuid(),
          "@_dmnElementRef": `${definedNamespaces.get(namespace)}:${id}`, // needs to use drgElement id
          "dc:Bounds": {
            "@_x": 0,
            "@_y": 0,
            ...MIN_NODE_SIZES[getNodeTypeFromDmnObject(drgElement![0]) ?? "node_unknown"]({
              snapGrid: {
                isEnabled: true,
                x: 20,
                y: 20,
              },
              isAlternativeInputDataShape: false,
            }),
          },
        });
      }
    }
  });

  // Create DRD
  model.definitions["dmndi:DMNDI"] = {
    ...model.definitions["dmndi:DMNDI"],
    "dmndi:DMNDiagram": [
      {
        "@_id": generateUuid(),
        "@_name": getDefaultDrdName({ drdIndex: 0 }),
        "@_useAlternativeInputDataShape": false,
        "dmndi:DMNDiagramElement": [...diagramElement, ...externalDMNDiagramElement],
        "di:extension": { "kie:ComponentsWidthsExtension": { "kie:ComponentWidths": [{}] } },
      },
    ],
  };
}
