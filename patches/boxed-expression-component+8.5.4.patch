diff --git a/node_modules/boxed-expression-component/src/__tests__/__mocks__/ReactWithSupervisor.ts b/node_modules/boxed-expression-component/src/__tests__/__mocks__/ReactWithSupervisor.ts
deleted file mode 100644
index 1e1c4ce..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/__mocks__/ReactWithSupervisor.ts
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-jest.mock("react", () => {
-  const actualReact = jest.requireActual("react");
-
-  function useContext<T>(context: React.Context<T>) {
-    return {
-      ...actualReact.useContext(context),
-      ...{
-        setSupervisorHash: (hash: number) => hash,
-      },
-    };
-  }
-
-  return {
-    ...actualReact,
-    useContext: useContext,
-  };
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/__mocks__/monacoMock.js b/node_modules/boxed-expression-component/src/__tests__/__mocks__/monacoMock.js
deleted file mode 100644
index 4760c6d..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/__mocks__/monacoMock.js
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-const languages = [];
-let value = "new value";
-let onDidBlurEditorText;
-
-module.exports = {
-  languages: {
-    registeredLanguages: [],
-    register: (language) => {
-      languages.push(language);
-    },
-    getLanguages: () => {
-      return languages;
-    },
-    setMonarchTokensProvider: (_name, _tokens) => {},
-    registerCompletionItemProvider: (_name, _provider) => {},
-    CompletionItemKind: {
-      Keyword: "Keyword",
-      Function: "Function",
-    },
-    CompletionItemInsertTextRule: {
-      InsertAsSnippet: "InsertAsSnippet",
-    },
-  },
-  editor: {
-    defineTheme: (_name, _theme) => {},
-    colorize: () => ({
-      then: (fn) => fn(),
-    }),
-    create: (element, _config) => {
-      element.innerHTML = "<monaco-editor-mock />";
-      return {
-        dispose: () => {},
-        getValue: () => value,
-        setValue: (newValue) => {
-          if (newValue.includes("</>")) {
-            onDidBlurEditorText(newValue);
-          }
-        },
-        setPosition: (_v) => {},
-        focus: () => {},
-        onDidChangeModelContent: () => {},
-        onDidBlurEditorText: (fn) => (onDidBlurEditorText = fn),
-        onKeyDown: () => {},
-      };
-    },
-  },
-};
diff --git a/node_modules/boxed-expression-component/src/__tests__/api/BoxedExpressionEditor.test.ts b/node_modules/boxed-expression-component/src/__tests__/api/BoxedExpressionEditor.test.ts
deleted file mode 100644
index bf039d1..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/api/BoxedExpressionEditor.test.ts
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { executeIfExpressionDefinitionChanged, LogicType } from "../../api";
-
-describe("BoxedExpressionEditor tests", () => {
-  describe("executeIfExpressionDefinitionChanged function", () => {
-    test("when prevDef and updatedDef are not equal, functionToExecute gets executed", () => {
-      const mockedFunctionToExecute = jest.fn();
-
-      executeIfExpressionDefinitionChanged({ name: "1" }, { name: "2" }, mockedFunctionToExecute, ["name"]);
-
-      expect(mockedFunctionToExecute).toHaveBeenCalledTimes(1);
-    });
-
-    test("when prevDef and updatedDef are equal, functionToExecute is not executed", () => {
-      const mockedFunctionToExecute = jest.fn();
-
-      executeIfExpressionDefinitionChanged({ name: "1" }, { name: "1" }, mockedFunctionToExecute, ["name"]);
-
-      expect(mockedFunctionToExecute).toHaveBeenCalledTimes(0);
-    });
-
-    test("when prevDef and updatedDef are not equal, but propertiesToCheck contains a field for which they are equal, functionToExecute is not executed", () => {
-      const mockedFunctionToExecute = jest.fn();
-
-      executeIfExpressionDefinitionChanged(
-        { name: "1", logicType: LogicType.Undefined },
-        { name: "1", logicType: LogicType.LiteralExpression },
-        mockedFunctionToExecute,
-        ["name"]
-      );
-
-      expect(mockedFunctionToExecute).toHaveBeenCalledTimes(0);
-    });
-
-    test("when prevDef and updatedDef are not equal and propertiesToCheck is not passed, functionToExecute gets executed", () => {
-      const mockedFunctionToExecute = jest.fn();
-
-      executeIfExpressionDefinitionChanged({ name: "1" }, { name: "2" }, mockedFunctionToExecute);
-
-      expect(mockedFunctionToExecute).toHaveBeenCalledTimes(1);
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/api/EnumUtils.test.ts b/node_modules/boxed-expression-component/src/__tests__/api/EnumUtils.test.ts
deleted file mode 100644
index 5522015..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/api/EnumUtils.test.ts
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { getEnumKeyByEnumValue } from "../../api";
-
-describe("EnumUtils tests", () => {
-  test("given an enum value, it should return its key", () => {
-    enum Enum {
-      OneKey = "val",
-      AnotherKey = "anotherVal",
-    }
-
-    expect(getEnumKeyByEnumValue(Enum, "val")).toBe("OneKey");
-  });
-
-  test("given an enum, where multiple keys have the same value, it should return one of its keys", () => {
-    enum Enum {
-      AnotherKey = "val",
-      OneKey = "val",
-    }
-
-    expect(getEnumKeyByEnumValue(Enum, "val")).toBeOneOf(["AnotherKey", "OneKey"]);
-  });
-
-  test("given an enum, where no key has the passed value, it should return null", () => {
-    enum Enum {
-      AnotherKey = "val",
-      OneKey = "another",
-    }
-
-    expect(getEnumKeyByEnumValue(Enum, "not present")).toBeNull();
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/BoxedExpressionEditor/BoxedExpressionEditor.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/BoxedExpressionEditor/BoxedExpressionEditor.test.tsx
deleted file mode 100644
index 6fff12e..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/BoxedExpressionEditor/BoxedExpressionEditor.test.tsx
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import * as React from "react";
-import { render } from "@testing-library/react";
-import { BoxedExpressionEditor } from "../../../components";
-import { DataType, ExpressionProps } from "../../../api";
-
-describe("BoxedExpressionEditor tests", () => {
-  test("should render BoxedExpressionEditor component", () => {
-    const selectedExpression: ExpressionProps = { name: "Expression Name", dataType: DataType.Undefined };
-
-    const { container } = render(
-      <BoxedExpressionEditor
-        decisionNodeId="_00000000-0000-0000-0000-000000000000"
-        expressionDefinition={selectedExpression}
-      />
-    );
-
-    expect(container).toMatchSnapshot();
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/BoxedExpressionEditor/__snapshots__/BoxedExpressionEditor.test.tsx.snap b/node_modules/boxed-expression-component/src/__tests__/components/BoxedExpressionEditor/__snapshots__/BoxedExpressionEditor.test.tsx.snap
deleted file mode 100644
index 192b325..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/BoxedExpressionEditor/__snapshots__/BoxedExpressionEditor.test.tsx.snap
+++ /dev/null
@@ -1,52 +0,0 @@
-// Jest Snapshot v1, https://goo.gl/fbAQLP
-
-exports[`BoxedExpressionEditor tests should render BoxedExpressionEditor component 1`] = `
-<div>
-  <div
-    class="react-resizable-supervisor"
-  >
-    <div
-      class="boxed-expression-provider"
-    >
-      <div
-        class="expression-container"
-      >
-        <div
-          class="expression-name-and-logic-type"
-        >
-          <span
-            class="expression-title"
-          >
-            Expression Name
-          </span>
-          <span
-            class="expression-type"
-          >
-            (
-            &lt;Undefined&gt;
-            )
-          </span>
-        </div>
-        <div
-          class="expression-container-box"
-          data-ouia-component-id="expression-container"
-        >
-          <div
-            class="_00000000-0000-0000-0000-000000000000 logic-type-selector logic-type-not-present"
-          >
-            Select expression
-          </div>
-        </div>
-      </div>
-    </div>
-  </div>
-  <div
-    class="kie-cell-selection-box"
-  >
-    <div
-      class="kie-selection-box"
-    />
-    <textarea />
-  </div>
-</div>
-`;
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryExpression.test.tsx
deleted file mode 100644
index 5a27dc8..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryExpression.test.tsx
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { DataType, LogicType } from "../../../api";
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { ContextEntryExpression } from "../../../components/ContextExpression";
-import * as _ from "lodash";
-import * as React from "react";
-
-describe("ContextEntryExpression tests", () => {
-  const name = "Expression Name";
-  const dataType = DataType.Boolean;
-  const emptyExpression = { name, dataType };
-
-  test("should show a context entry element with logic type not selected, when rendering it with an empty expression", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryExpression expression={emptyExpression} onUpdatingRecursiveExpression={_.identity} />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".entry-expression")).toBeTruthy();
-    expect(container.querySelector(".entry-expression .logic-type-selector")).toHaveClass("logic-type-not-present");
-  });
-
-  test("should show a context entry element with selected logic type, when rendering it with an expression", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryExpression
-          expression={{ ...emptyExpression, logicType: LogicType.LiteralExpression }}
-          onUpdatingRecursiveExpression={_.identity}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".entry-expression")).toBeTruthy();
-    expect(container.querySelector(".entry-expression .logic-type-selector")).toHaveClass("logic-type-selected");
-  });
-
-  test("should show a context entry element with logic type not selected, when rendering it with an empty expression", () => {
-    const content = <div id="content">content</div>;
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryExpression expression={emptyExpression} onUpdatingRecursiveExpression={_.identity}>
-          {content}
-        </ContextEntryExpression>
-      ).wrapper
-    );
-
-    expect(container.querySelector(".entry-expression")).toBeTruthy();
-    expect(container.querySelector(".entry-expression .logic-type-selector")).toHaveClass("logic-type-not-present");
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryExpressionCell.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryExpressionCell.test.tsx
deleted file mode 100644
index 8e21df8..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryExpressionCell.test.tsx
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { DataType, LogicType } from "../../../api";
-import { render } from "@testing-library/react";
-import { flushPromises, usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { ContextEntryExpressionCell } from "../../../components/ContextExpression";
-import * as _ from "lodash";
-import * as React from "react";
-import { DataRecord } from "react-table";
-import { act } from "react-dom/test-utils";
-
-jest.useFakeTimers();
-
-describe("ContextEntryExpressionCell tests", () => {
-  const name = "Expression Name";
-  const dataType = DataType.Boolean;
-  const emptyExpression = { name, dataType };
-  const entryId = "entry-id1";
-  const entryName = "entry name";
-  const entryDataType = DataType.Date;
-
-  const value = "value";
-  const rowIndex = 0;
-  const onRowUpdate: (rowIndex: number, updatedRow: DataRecord) => void = (rowIndex, updatedRow) =>
-    _.identity({ rowIndex, updatedRow });
-
-  test("should show a context entry expression cell with logic type not selected", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryExpressionCell
-          data={[
-            {
-              entryInfo: { id: entryId, name: entryName, dataType: entryDataType },
-              entryExpression: emptyExpression,
-            },
-          ]}
-          rowIndex={0}
-          columnId={"col1"}
-          onRowUpdate={_.identity}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".context-entry-expression-cell")).toBeTruthy();
-    expect(container.querySelector(".entry-expression .logic-type-selector")).toHaveClass("logic-type-not-present");
-  });
-
-  test("should trigger onRowUpdate function when something in the context entry expression changes", async () => {
-    const mockedOnRowUpdate = jest.fn(onRowUpdate);
-
-    const { container, baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryExpressionCell
-          data={[
-            {
-              entryInfo: { id: entryId, name: value, dataType },
-              entryExpression: emptyExpression,
-            },
-          ]}
-          rowIndex={rowIndex}
-          columnId={"columnId"}
-          onRowUpdate={mockedOnRowUpdate}
-        />
-      ).wrapper
-    );
-
-    (container.querySelector(".entry-expression")! as HTMLDivElement).click();
-    await act(async () => {
-      await flushPromises();
-      jest.runAllTimers();
-      Array.from(baseElement.querySelectorAll("button"))
-        .find((el) => el.textContent === LogicType.LiteralExpression)!
-        .click();
-    });
-
-    expect(mockedOnRowUpdate).toHaveBeenCalled();
-    expect(mockedOnRowUpdate).toHaveBeenCalledWith(rowIndex, {
-      entryInfo: {
-        id: entryId,
-        name: value,
-        dataType,
-      },
-      entryExpression: {
-        logicType: LogicType.LiteralExpression,
-        name,
-        dataType,
-      },
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryInfo.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryInfo.test.tsx
deleted file mode 100644
index 0f8e460..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryInfo.test.tsx
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { DataType } from "../../../api";
-import { EDIT_EXPRESSION_NAME, updateElementViaPopover, usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { render } from "@testing-library/react";
-import { ContextEntryInfo } from "../../../components/ContextExpression";
-import * as _ from "lodash";
-import * as React from "react";
-
-jest.useFakeTimers();
-
-describe("ContextEntryInfo tests", () => {
-  const id = "id1";
-  const name = "Expression Name";
-  const newValue = "New Value";
-  const dataType = DataType.Boolean;
-
-  test("should show a context entry info element with passed name and dataType, when rendering it", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryInfo
-          id={id}
-          name={name}
-          dataType={dataType}
-          editInfoPopoverLabel="Edit entry"
-          onContextEntryUpdate={_.identity}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".entry-info")).toBeTruthy();
-    expect(container.querySelector(".entry-info")).toHaveClass(id);
-    expect(container.querySelector(".entry-info .entry-definition")).toBeTruthy();
-    expect(container.querySelector(".entry-info .entry-definition .entry-name")).toContainHTML(name);
-    expect(container.querySelector(".entry-info .entry-definition .entry-data-type")).toContainHTML(dataType);
-  });
-
-  test("should call the onContextEntryUpdate callback when one of its prop changes", async () => {
-    const onContextEntryUpdate: (name: string, dataType: DataType) => void = (name, dataType) =>
-      _.identity({ name, dataType });
-    const mockedOnContextEntryUpdate = jest.fn(onContextEntryUpdate);
-
-    const { container, baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryInfo
-          id={id}
-          name={name}
-          dataType={dataType}
-          editInfoPopoverLabel="Edit entry"
-          onContextEntryUpdate={mockedOnContextEntryUpdate}
-        />
-      ).wrapper
-    );
-
-    await updateElementViaPopover(
-      container.querySelector(".entry-definition") as HTMLTableHeaderCellElement,
-      baseElement,
-      EDIT_EXPRESSION_NAME,
-      newValue
-    );
-
-    expect(mockedOnContextEntryUpdate).toHaveBeenCalled();
-    expect(mockedOnContextEntryUpdate).toHaveBeenCalledWith(newValue, dataType);
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryInfoCell.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryInfoCell.test.tsx
deleted file mode 100644
index 4665fe2..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextEntryInfoCell.test.tsx
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { EDIT_EXPRESSION_NAME, updateElementViaPopover, usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { ContextEntryInfoCell } from "../../../components/ContextExpression";
-import * as _ from "lodash";
-import * as React from "react";
-import { DataType } from "../../../api";
-import { DataRecord } from "react-table";
-
-jest.useFakeTimers();
-
-describe("ContextEntryInfoCell tests", () => {
-  const id = "id1";
-  const name = "Expression Name";
-  const newValue = "New Value";
-  const dataType = DataType.Boolean;
-  const emptyExpression = { name, dataType };
-  const onRowUpdate: (rowIndex: number, updatedRow: DataRecord) => void = (rowIndex, updatedRow) =>
-    _.identity({ rowIndex, updatedRow });
-
-  test("should show a context entry info cell element with passed name and dataType, when rendering it", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryInfoCell
-          data={[{ entryInfo: { id, name, dataType }, entryExpression: emptyExpression }]}
-          rowIndex={0}
-          columnId={"col1"}
-          onRowUpdate={_.identity}
-          editInfoPopoverLabel="Edit entry"
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".context-entry-info-cell")).toBeTruthy();
-    expect(container.querySelector(".context-entry-info-cell .entry-info")).toHaveClass(id);
-    expect(container.querySelector(".context-entry-info-cell .entry-info")).toBeTruthy();
-    expect(container.querySelector(".context-entry-info-cell .entry-info .entry-definition")).toBeTruthy();
-    expect(container.querySelector(".context-entry-info-cell .entry-info .entry-definition .entry-name")).toContainHTML(
-      name
-    );
-    expect(
-      container.querySelector(".context-entry-info-cell .entry-info .entry-definition .entry-data-type")
-    ).toContainHTML(dataType);
-  });
-
-  test("should trigger onRowUpdate function when something in the context entry info changes", async () => {
-    const mockedOnRowUpdate = jest.fn(onRowUpdate);
-
-    const { container, baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <ContextEntryInfoCell
-          data={[{ entryInfo: { id, name, dataType }, entryExpression: emptyExpression }]}
-          rowIndex={0}
-          columnId={"col1"}
-          onRowUpdate={mockedOnRowUpdate}
-          editInfoPopoverLabel="Edit entry"
-        />
-      ).wrapper
-    );
-
-    await updateElementViaPopover(
-      container.querySelector(".entry-definition") as HTMLTableHeaderCellElement,
-      baseElement,
-      EDIT_EXPRESSION_NAME,
-      newValue
-    );
-
-    expect(mockedOnRowUpdate).toHaveBeenCalled();
-    expect(mockedOnRowUpdate).toHaveBeenCalledWith(0, {
-      entryInfo: {
-        id,
-        name: newValue,
-        dataType,
-      },
-      entryExpression: emptyExpression,
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextExpression.test.tsx
deleted file mode 100644
index 929f275..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ContextExpression/ContextExpression.test.tsx
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../__mocks__/ReactWithSupervisor";
-import { render } from "@testing-library/react";
-import {
-  checkEntryContent,
-  checkEntryLogicType,
-  checkEntryStyle,
-  contextEntry,
-  usingTestingBoxedExpressionI18nContext,
-  usingTestingBoxedExpressionProviderContext,
-} from "../test-utils";
-import { ContextExpression } from "../../../components/ContextExpression";
-import * as React from "react";
-import { DataType, LogicType } from "../../../api";
-
-describe("ContextExpression tests", () => {
-  const name = "contextName";
-  const dataType = DataType.Boolean;
-  test("should show a table with two rows: two context entries, where last is representing the result", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <ContextExpression logicType={LogicType.Context} name={name} dataType={dataType} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".context-expression")).toBeTruthy();
-    expect(container.querySelector(".context-expression table")).toBeTruthy();
-    expect(container.querySelectorAll(".context-expression table tbody tr")).toHaveLength(2);
-    expect(container.querySelector(".context-expression table tbody tr:first-of-type")).toContainHTML("ContextEntry-1");
-    expect(container.querySelector(".context-expression table tbody tr:last-of-type")).toContainHTML("result");
-  });
-
-  test("should show a table with one row for each passed entry, plus the passed entry result", () => {
-    const firstEntryId = "id1";
-    const firstEntry = "first entry";
-    const firstDataType = DataType.Boolean;
-    const firstExpression = { name: "expressionName", dataType: DataType.Any, logicType: LogicType.LiteralExpression };
-    const secondEntryId = "id2";
-    const secondEntry = "second entry";
-    const secondDataType = DataType.Date;
-    const secondExpression = { name: "anotherName", dataType: DataType.Undefined };
-    const resultEntry = "result entry";
-    const resultDataType = DataType.Undefined;
-
-    const contextEntries = [
-      {
-        entryInfo: {
-          id: firstEntryId,
-          name: firstEntry,
-          dataType: firstDataType,
-        },
-        entryExpression: firstExpression,
-        editInfoPopoverLabel: "Edit entry",
-      },
-      {
-        entryInfo: {
-          id: secondEntryId,
-          name: secondEntry,
-          dataType: secondDataType,
-        },
-        entryExpression: secondExpression,
-        editInfoPopoverLabel: "Edit entry",
-      },
-    ];
-
-    const result = {
-      name: resultEntry,
-      dataType: resultDataType,
-      expression: {},
-    };
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <ContextExpression
-            logicType={LogicType.Context}
-            name={name}
-            dataType={dataType}
-            contextEntries={contextEntries}
-            result={result}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".context-expression")).toBeTruthy();
-    expect(container.querySelector(".context-expression table")).toBeTruthy();
-    expect(container.querySelectorAll(".context-expression table tbody tr")).toHaveLength(3);
-
-    checkEntryContent(contextEntry(container, 1), { id: firstEntryId, name: firstEntry, dataType: firstDataType });
-    checkEntryContent(contextEntry(container, 2), { id: secondEntryId, name: secondEntry, dataType: secondDataType });
-    checkEntryContent(contextEntry(container, 3), { name: "result", dataType: "" });
-
-    checkEntryStyle(contextEntry(container, 1), "logic-type-selected");
-    checkEntryLogicType(contextEntry(container, 1), "literal-expression");
-    checkEntryStyle(contextEntry(container, 2), "logic-type-not-present");
-    checkEntryStyle(contextEntry(container, 3), "logic-type-not-present");
-  });
-});
-
-jest.mock("../../../api", () => ({
-  ...(jest.requireActual("../../../api") as Record<string, unknown>),
-  getHandlerConfiguration: jest.fn(),
-}));
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/DecisionTableExpression/DecisionTableExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/DecisionTableExpression/DecisionTableExpression.test.tsx
deleted file mode 100644
index 13a119d..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/DecisionTableExpression/DecisionTableExpression.test.tsx
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { DataType, DecisionTableProps, HitPolicy, LogicType } from "../../../api";
-import { fireEvent, render } from "@testing-library/react";
-import {
-  flushPromises,
-  usingTestingBoxedExpressionI18nContext,
-  usingTestingBoxedExpressionProviderContext,
-  wrapComponentInContext,
-} from "../test-utils";
-import * as React from "react";
-import { DecisionTableExpression } from "../../../components/DecisionTableExpression";
-import { openContextMenu } from "../Table/Table.test";
-import * as _ from "lodash";
-import { act } from "react-dom/test-utils";
-
-describe("DecisionTableExpression tests", () => {
-  test("should show a table with three columns: input, output and annotation, and one row", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <DecisionTableExpression id="decision-node-id" logicType={LogicType.DecisionTable} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".decision-table-expression")).toBeTruthy();
-    expect(container.querySelector(".decision-table-expression table")).toBeTruthy();
-    expect(
-      container.querySelectorAll(".decision-table-expression table thead tr:last-of-type th:not(.fixed-column)")
-    ).toHaveLength(3);
-    expect(container.querySelectorAll(".decision-table-expression table thead tr:last-of-type th.input")).toHaveLength(
-      1
-    );
-    expect(container.querySelectorAll(".decision-table-expression table thead tr:last-of-type th.output")).toHaveLength(
-      1
-    );
-    expect(
-      container.querySelectorAll(".decision-table-expression table thead tr:last-of-type th.annotation")
-    ).toHaveLength(1);
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr")).toHaveLength(1);
-  });
-
-  test("should show as default hit policy, unique", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <DecisionTableExpression id="decision-node-id" logicType={LogicType.DecisionTable} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".decision-table-expression .selected-hit-policy")).toContainHTML("U");
-  });
-
-  test("should show the passed hit policy", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <DecisionTableExpression
-            id="decision-node-id"
-            logicType={LogicType.DecisionTable}
-            hitPolicy={HitPolicy.First}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".decision-table-expression .selected-hit-policy")).toContainHTML("F");
-  });
-
-  test("should show as default a row, with empty values, except for input column, whose value is dash symbol", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <DecisionTableExpression id="decision-node-id" logicType={LogicType.DecisionTable} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")).toHaveLength(3);
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")[0]).toHaveTextContent(
-      "-"
-    );
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")[1]).toHaveTextContent(
-      ""
-    );
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")[2]).toHaveTextContent(
-      ""
-    );
-  });
-
-  test("should show the passed input, output and annotations", () => {
-    const inputName = "input name";
-    const outputName = "output name";
-    const annotationName = "annotation name";
-    const input = [{ id: "input", name: inputName, dataType: DataType.Undefined }];
-    const output = [{ id: "output", name: outputName, dataType: DataType.Undefined }];
-    const annotations = [{ id: "annotation", name: annotationName }];
-    const inputEntry = "input entry";
-    const outputEntry = "output entry";
-    const annotation = "annotation";
-    const rules = [
-      { id: "rule-1", inputEntries: [inputEntry], outputEntries: [outputEntry], annotationEntries: [annotation] },
-    ];
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <DecisionTableExpression
-            id="decision-node-id"
-            logicType={LogicType.DecisionTable}
-            input={input}
-            output={output}
-            annotations={annotations}
-            rules={rules}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(
-      container.querySelector(".decision-table-expression table thead tr:last-of-type th.input")
-    ).toHaveTextContent(inputName);
-    expect(
-      container.querySelector(".decision-table-expression table thead tr:last-of-type th.output")
-    ).toHaveTextContent(outputName);
-    expect(
-      container.querySelector(".decision-table-expression table thead tr:last-of-type th.annotation")
-    ).toHaveTextContent(annotationName);
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")).toHaveLength(3);
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")[0]).toHaveTextContent(
-      inputEntry
-    );
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")[1]).toHaveTextContent(
-      outputEntry
-    );
-    expect(container.querySelectorAll(".decision-table-expression table tbody tr td.data-cell")[2]).toHaveTextContent(
-      annotation
-    );
-  });
-
-  test("should append a row, with empty values, except for input column, whose value is dash symbol, when user inserts a row below", async () => {
-    const mockedBroadcastDefinition = jest.fn();
-    mockBroadcastDefinition(mockedBroadcastDefinition);
-    const { container, baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        wrapComponentInContext(<DecisionTableExpression id="decision-node-id" logicType={LogicType.DecisionTable} />)
-      ).wrapper
-    );
-
-    await openContextMenu(container.querySelector(".decision-table-expression table tbody tr td.counter-cell")!);
-    await act(async () => {
-      fireEvent.click(
-        baseElement.querySelector("[data-ouia-component-id='expression-table-handler-menu-Insert below'] button")!
-      );
-      await flushPromises();
-      jest.runAllTimers();
-    });
-
-    expect(mockedBroadcastDefinition).toHaveBeenLastCalledWith(
-      expect.objectContaining({
-        rules: [
-          expect.objectContaining({
-            inputEntries: ["-"],
-            outputEntries: [""],
-            annotationEntries: [""],
-          }),
-          expect.objectContaining({
-            inputEntries: ["-"],
-            outputEntries: [""],
-            annotationEntries: [""],
-          }),
-        ],
-      })
-    );
-  });
-
-  function mockBroadcastDefinition(mockedBroadcastDefinition: jest.Mock) {
-    window.beeApi = _.extend(window.beeApi || {}, {
-      broadcastDecisionTableExpressionDefinition: (definition: DecisionTableProps) =>
-        mockedBroadcastDefinition(definition),
-      notifyUserAction: () => {},
-    });
-  }
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/DecisionTableExpression/HitPolicySelector.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/DecisionTableExpression/HitPolicySelector.test.tsx
deleted file mode 100644
index 41e6092..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/DecisionTableExpression/HitPolicySelector.test.tsx
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { flushPromises, usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { HitPolicySelector } from "../../../components/DecisionTableExpression";
-import { BuiltinAggregation, HitPolicy } from "../../../api";
-import * as React from "react";
-import * as _ from "lodash";
-import { act } from "react-dom/test-utils";
-
-jest.useFakeTimers();
-
-describe("HitPolicySelector tests", () => {
-  test("should show passed hit policy without aggregation, when hit policy is collect, but aggregation is none", () => {
-    const { baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.Collect}
-          selectedBuiltInAggregator={BuiltinAggregation["<None>"]}
-          onHitPolicySelect={_.identity}
-          onBuiltInAggregatorSelect={_.identity}
-        />
-      ).wrapper
-    );
-    expect(baseElement.querySelector(".selected-hit-policy")).toBeTruthy();
-    expect(baseElement.querySelector(".selected-hit-policy")).toHaveTextContent("C");
-  });
-
-  test("should show passed hit policy plus aggregation, when hit policy is collect and aggregation is not none", () => {
-    const { baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.Collect}
-          selectedBuiltInAggregator={BuiltinAggregation.COUNT}
-          onHitPolicySelect={_.identity}
-          onBuiltInAggregatorSelect={_.identity}
-        />
-      ).wrapper
-    );
-    expect(baseElement.querySelector(".selected-hit-policy")).toBeTruthy();
-    expect(baseElement.querySelector(".selected-hit-policy")).toHaveTextContent("C#");
-  });
-
-  test("should show passed hit policy without aggregation, when aggregation is not collect", () => {
-    const { baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.Any}
-          selectedBuiltInAggregator={BuiltinAggregation.COUNT}
-          onHitPolicySelect={_.identity}
-          onBuiltInAggregatorSelect={_.identity}
-        />
-      ).wrapper
-    );
-    expect(baseElement.querySelector(".selected-hit-policy")).toBeTruthy();
-    expect(baseElement.querySelector(".selected-hit-policy")).toHaveTextContent("A");
-  });
-
-  test("should allow aggregator selection, when hit policy is collect", async () => {
-    const { baseElement, container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.Collect}
-          selectedBuiltInAggregator={BuiltinAggregation.COUNT}
-          onHitPolicySelect={_.identity}
-          onBuiltInAggregatorSelect={_.identity}
-        />
-      ).wrapper
-    );
-
-    await activateHitPolicyPopover(container);
-
-    expect(baseElement.querySelector(".builtin-aggregator-selector button")).not.toHaveAttribute("disabled");
-  });
-
-  test("should avoid aggregator selection, when hit policy is not collect", async () => {
-    const { baseElement, container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.First}
-          selectedBuiltInAggregator={BuiltinAggregation["<None>"]}
-          onHitPolicySelect={_.identity}
-          onBuiltInAggregatorSelect={_.identity}
-        />
-      ).wrapper
-    );
-
-    await activateHitPolicyPopover(container);
-
-    expect(baseElement.querySelector(".builtin-aggregator-selector button")).toHaveAttribute("disabled");
-  });
-
-  test("should trigger a callback, when hit policy is selected", async () => {
-    const mockedHitPolicySelect = jest.fn();
-    const changedHitPolicy = HitPolicy.Any;
-
-    const { baseElement, container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.First}
-          selectedBuiltInAggregator={BuiltinAggregation["<None>"]}
-          onHitPolicySelect={mockedHitPolicySelect}
-          onBuiltInAggregatorSelect={_.identity}
-        />
-      ).wrapper
-    );
-
-    await activateHitPolicyPopover(container);
-    await openDropdown(baseElement, "hit-policy-selector");
-    await changeDropdownSelection(baseElement, changedHitPolicy);
-
-    expect(mockedHitPolicySelect).toHaveBeenCalledWith(changedHitPolicy);
-  });
-
-  test("should trigger a callback, when aggregation is selected", async () => {
-    const mockedAggregationSelect = jest.fn();
-    const changedAggregation = "MAX" as BuiltinAggregation;
-
-    const { baseElement, container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <HitPolicySelector
-          selectedHitPolicy={HitPolicy.Collect}
-          selectedBuiltInAggregator={BuiltinAggregation["<None>"]}
-          onHitPolicySelect={_.identity}
-          onBuiltInAggregatorSelect={mockedAggregationSelect}
-        />
-      ).wrapper
-    );
-
-    await activateHitPolicyPopover(container);
-    await openDropdown(baseElement, "builtin-aggregator-selector");
-    await changeDropdownSelection(baseElement, changedAggregation);
-
-    expect(mockedAggregationSelect).toHaveBeenCalledWith(changedAggregation);
-  });
-
-  async function activateHitPolicyPopover(container: Element) {
-    await act(async () => {
-      (container.querySelector(".selected-hit-policy") as HTMLDivElement).click();
-      await flushPromises();
-      jest.runAllTimers();
-    });
-  }
-
-  async function openDropdown(baseElement: Element, dropdownClass: string) {
-    await act(async () => {
-      (baseElement.querySelector(`.${dropdownClass} button`) as HTMLButtonElement).click();
-      await flushPromises();
-      jest.runAllTimers();
-    });
-  }
-
-  async function changeDropdownSelection(baseElement: Element, selection: HitPolicy | BuiltinAggregation) {
-    await act(async () => {
-      (baseElement.querySelector(`[data-ouia-component-id='${selection}']`) as HTMLButtonElement).click();
-      await flushPromises();
-      jest.runAllTimers();
-    });
-  }
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/EditExpressionMenu.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/EditExpressionMenu.test.tsx
deleted file mode 100644
index e30b9a6..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/EditExpressionMenu.test.tsx
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { fireEvent, render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import * as React from "react";
-import { EditExpressionMenu } from "../../../components/EditExpressionMenu";
-import { activatePopover } from "../PopoverMenu/PopoverMenu.test";
-import { DataType, ExpressionProps, LogicType } from "../../../api";
-import * as _ from "lodash";
-
-jest.useFakeTimers();
-
-describe("EditExpressionMenu tests", () => {
-  test("should render Edit Expression title", async () => {
-    const title = "Edit Expression";
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName="Expression Name"
-            title={title}
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={(expression) => {
-              console.log(expression);
-            }}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector(".selector-menu-title")).toBeTruthy();
-    expect(container.querySelector(".selector-menu-title")!.innerHTML).toBe(title);
-  });
-
-  test("should render custom name field label", async () => {
-    const nameFieldLabel = "custom name field label";
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName="Expression Name"
-            nameField={nameFieldLabel}
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={(expression) => {
-              console.log(expression);
-            }}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector(".expression-name label")).toBeTruthy();
-    expect(container.querySelector(".expression-name label")!.innerHTML).toBe(nameFieldLabel);
-  });
-
-  test("should render custom data type field label", async () => {
-    const dataTypeFieldLabel = "custom data type field label";
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName="Expression Name"
-            dataTypeField={dataTypeFieldLabel}
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={(expression) => {
-              console.log(expression);
-            }}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector(".expression-data-type label")).toBeTruthy();
-    expect(container.querySelector(".expression-data-type label")!.innerHTML).toBe(dataTypeFieldLabel);
-  });
-
-  test("should render undefined as data type, when it is not pre-selected", async () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName="Expression Name"
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={(expression) => {
-              console.log(expression);
-            }}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector("[id^='pf-select-toggle-id-']")).toBeTruthy();
-    expect((container.querySelector("[id^='pf-select-toggle-id-']")! as HTMLInputElement).value).toBe(
-      LogicType.Undefined
-    );
-  });
-
-  test("should render passed data type, when it is pre-selected", async () => {
-    const selectedDataType = DataType.Date;
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName="Expression Name"
-            selectedDataType={selectedDataType}
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={(expression) => {
-              console.log(expression);
-            }}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector("[id^='pf-select-toggle-id-']")).toBeTruthy();
-    expect((container.querySelector("[id^='pf-select-toggle-id-']")! as HTMLInputElement).value).toBe(selectedDataType);
-  });
-
-  test("should render passed expression name, when it is pre-selected", async () => {
-    const expressionName = "a name";
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName={expressionName}
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={(expression) => {
-              console.log(expression);
-            }}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector("#expression-name")).toBeTruthy();
-    expect((container.querySelector("#expression-name")! as HTMLInputElement).value).toBe(expressionName);
-  });
-
-  test("should trigger the onExpressionUpdate callback when the expression name is changed", async () => {
-    const onExpressionUpdate = (expression: ExpressionProps) => {
-      _.identity(expression);
-    };
-    const mockedOnExpressionUpdate = jest.fn(onExpressionUpdate);
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <EditExpressionMenu
-            selectedExpressionName="init"
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            onExpressionUpdate={mockedOnExpressionUpdate}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    const input = container.querySelector("#expression-name") as HTMLInputElement;
-    fireEvent.blur(input, { target: { value: "changed" } });
-
-    expect(mockedOnExpressionUpdate).toHaveBeenCalled();
-    expect(mockedOnExpressionUpdate).toHaveBeenCalledWith({
-      name: "changed",
-      dataType: DataType.Undefined,
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/EditTextInline.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/EditTextInline.test.tsx
deleted file mode 100644
index 49bbee9..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/EditTextInline.test.tsx
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { fireEvent, render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { EditTextInline } from "../../../components/EditExpressionMenu";
-import * as React from "react";
-import * as _ from "lodash";
-
-describe("EditTextInline tests", () => {
-  test("should render inline text", () => {
-    const value = "Value";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(<EditTextInline value={value} onTextChange={_.identity} />).wrapper
-    );
-
-    expect(container.querySelector("p")).toBeTruthy();
-    expect(container.querySelector("p")).toHaveTextContent(value);
-  });
-
-  test("should activate text editing, when double clicking on it", () => {
-    const value = "Value";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(<EditTextInline value={value} onTextChange={_.identity} />).wrapper
-    );
-    fireEvent.click(container.querySelector("p")!);
-
-    expect(container.querySelector("input")).toBeTruthy();
-    expect(container.querySelector("input")).toHaveValue(value);
-  });
-
-  test("should call text editing callback, when clicking outside", () => {
-    const value = "Value";
-    const newValue = "New Value";
-    const mockedOnTextChange = jest.fn();
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div id="container">
-          <EditTextInline value={value} onTextChange={mockedOnTextChange} />
-        </div>
-      ).wrapper
-    );
-    fireEvent.click(container.querySelector("p")!);
-    fireEvent.blur(changeInputValue(container, newValue));
-
-    expect(mockedOnTextChange).toHaveBeenCalledWith(newValue);
-  });
-
-  test("should call text editing callback, when pressing enter", () => {
-    const value = "Value";
-    const newValue = "New Value";
-    const mockedOnTextChange = jest.fn();
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div id="container">
-          <EditTextInline value={value} onTextChange={mockedOnTextChange} />
-        </div>
-      ).wrapper
-    );
-    fireEvent.click(container.querySelector("p")!);
-    fireEvent.keyDown(changeInputValue(container, newValue), { key: "enter", keyCode: 13 });
-
-    expect(mockedOnTextChange).toHaveBeenCalledWith(newValue);
-  });
-
-  test("should not call text editing callback, when pressing escape", () => {
-    const value = "Value";
-    const newValue = "New Value";
-    const mockedOnTextChange = jest.fn();
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div id="container">
-          <EditTextInline value={value} onTextChange={mockedOnTextChange} />
-        </div>
-      ).wrapper
-    );
-    fireEvent.click(container.querySelector("p")!);
-    fireEvent.keyDown(changeInputValue(container, newValue), { key: "escape", keyCode: 27 });
-
-    expect(mockedOnTextChange).toHaveBeenCalledTimes(0);
-  });
-
-  function changeInputValue(container: Element, newValue: string) {
-    const inputElement = container.querySelector("input")!;
-    fireEvent.change(inputElement, {
-      target: { value: newValue },
-    });
-    return inputElement;
-  }
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/__snapshots__/EditExpressionMenu.test.tsx.snap b/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/__snapshots__/EditExpressionMenu.test.tsx.snap
deleted file mode 100644
index f4abeea..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/EditExpressionMenu/__snapshots__/EditExpressionMenu.test.tsx.snap
+++ /dev/null
@@ -1,72 +0,0 @@
-// Jest Snapshot v1, https://goo.gl/fbAQLP
-
-exports[`PopoverMenu tests should render PopoverMenu component 1`] = `
-<div>
-  <div>
-    <div
-      id="container"
-    >
-      Popover
-      <div
-        aria-describedby="popover-menu-selector-body"
-        aria-labelledby="popover-menu-selector-header"
-        aria-modal="true"
-        class="pf-c-popover popover-menu-selector pf-m-bottom"
-        data-ouia-component-id="expression-popover-menu"
-        data-popper-escaped="true"
-        data-popper-placement="bottom"
-        data-popper-reference-hidden="true"
-        role="dialog"
-        style="opacity: 1; transition: opacity 300ms cubic-bezier(.54, 1.5, .38, 1.11); position: absolute; left: 0px; top: 0px; z-index: 9999; transform: translate(0px, 0px);"
-      >
-        <div
-          class="pf-c-popover__arrow"
-        />
-        <div
-          class="pf-c-popover__content"
-        >
-          <button
-            aria-disabled="false"
-            aria-label="Close"
-            class="pf-c-button pf-m-plain"
-            data-ouia-component-id="OUIA-Generated-Button-plain-1"
-            data-ouia-component-type="PF4/Button"
-            data-ouia-safe="true"
-            style="pointer-events: auto;"
-            type="button"
-          >
-            <svg
-              aria-hidden="true"
-              fill="currentColor"
-              height="1em"
-              role="img"
-              style="vertical-align: -0.125em;"
-              viewBox="0 0 352 512"
-              width="1em"
-            >
-              <path
-                d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"
-              />
-            </svg>
-          </button>
-          <h6
-            class="pf-c-title pf-m-md"
-            id="popover-menu-selector-header"
-          >
-            <div
-              class="selector-menu-title"
-              data-ouia-component-id="expression-popover-menu-title"
-            >
-              title
-            </div>
-          </h6>
-          <div
-            class="pf-c-popover__body"
-            id="popover-menu-selector-body"
-          />
-        </div>
-      </div>
-    </div>
-  </div>
-</div>
-`;
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ExpressionContainer/ExpressionContainer.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ExpressionContainer/ExpressionContainer.test.tsx
deleted file mode 100644
index 9d55962..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ExpressionContainer/ExpressionContainer.test.tsx
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { ExpressionContainer } from "../../../components";
-import { render } from "@testing-library/react";
-import * as React from "react";
-import { usingTestingBoxedExpressionI18nContext, usingTestingBoxedExpressionProviderContext } from "../test-utils";
-import { DataType, LogicType } from "../../../api";
-
-describe("ExpressionContainer tests", () => {
-  test("should render ExpressionContainer component", () => {
-    const expression = { name: "Test", dataType: DataType.Undefined };
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<ExpressionContainer selectedExpression={expression} />, {
-          expressionDefinition: expression,
-        }).wrapper
-      ).wrapper
-    );
-
-    expect(container).toMatchSnapshot();
-  });
-
-  test("should render expression title, when name prop is passed", () => {
-    const expressionTitle = "Test";
-    const expression = { name: expressionTitle, dataType: DataType.Undefined };
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<ExpressionContainer selectedExpression={expression} />, {
-          expressionDefinition: expression,
-        }).wrapper
-      ).wrapper
-    );
-    expect(container.querySelector(".expression-title")).toBeTruthy();
-    expect(container.querySelector(".expression-title")!.innerHTML).toBe(expressionTitle);
-  });
-
-  test("should render expression type, when type prop is passed", () => {
-    const expression = { name: "Test", logicType: LogicType.LiteralExpression, dataType: DataType.Undefined };
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<ExpressionContainer selectedExpression={expression} />, {
-          expressionDefinition: expression,
-        }).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".expression-type")).toBeTruthy();
-    expect(container.querySelector(".expression-type")!.innerHTML).toBe("(" + LogicType.LiteralExpression + ")");
-  });
-
-  test("should render expression type as undefined, when type prop is not passed", () => {
-    const expression = { name: "Test", dataType: DataType.Undefined };
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<ExpressionContainer selectedExpression={expression} />, {
-          expressionDefinition: expression,
-        }).wrapper
-      ).wrapper
-    );
-    expect(container.querySelector(".expression-type")).toBeTruthy();
-    expect(container.querySelector(".expression-type")!.innerHTML).toBe("(&lt;Undefined&gt;)");
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ExpressionContainer/__snapshots__/ExpressionContainer.test.tsx.snap b/node_modules/boxed-expression-component/src/__tests__/components/ExpressionContainer/__snapshots__/ExpressionContainer.test.tsx.snap
deleted file mode 100644
index 227d987..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ExpressionContainer/__snapshots__/ExpressionContainer.test.tsx.snap
+++ /dev/null
@@ -1,52 +0,0 @@
-// Jest Snapshot v1, https://goo.gl/fbAQLP
-
-exports[`ExpressionContainer tests should render ExpressionContainer component 1`] = `
-<div>
-  <div
-    class="react-resizable-supervisor"
-  >
-    <div
-      class="boxed-expression-provider"
-    >
-      <div
-        class="expression-container"
-      >
-        <div
-          class="expression-name-and-logic-type"
-        >
-          <span
-            class="expression-title"
-          >
-            Test
-          </span>
-          <span
-            class="expression-type"
-          >
-            (
-            &lt;Undefined&gt;
-            )
-          </span>
-        </div>
-        <div
-          class="expression-container-box"
-          data-ouia-component-id="expression-container"
-        >
-          <div
-            class="_00000000-0000-0000-0000-000000000000 logic-type-selector logic-type-not-present"
-          >
-            Select expression
-          </div>
-        </div>
-      </div>
-    </div>
-  </div>
-  <div
-    class="kie-cell-selection-box"
-  >
-    <div
-      class="kie-selection-box"
-    />
-    <textarea />
-  </div>
-</div>
-`;
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/FunctionExpression/FunctionExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/FunctionExpression/FunctionExpression.test.tsx
deleted file mode 100644
index 5abff5d..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/FunctionExpression/FunctionExpression.test.tsx
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../__mocks__/ReactWithSupervisor";
-import { fireEvent, render } from "@testing-library/react";
-import {
-  activateSelector,
-  EDIT_EXPRESSION_DATA_TYPE,
-  flushPromises,
-  usingTestingBoxedExpressionI18nContext,
-  usingTestingBoxedExpressionProviderContext,
-} from "../test-utils";
-import { DEFAULT_FIRST_PARAM_NAME, FunctionExpression } from "../../../components/FunctionExpression";
-import * as React from "react";
-import { DataType, EntryInfo, FunctionKind, FunctionProps, LogicType } from "../../../api";
-import { act } from "react-dom/test-utils";
-import * as _ from "lodash";
-
-describe("FunctionExpression tests", () => {
-  const parameterId = "p1";
-  const documentName = "document";
-  const modelName = "model";
-
-  test("should show a table with two levels visible header, with one row and one column", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Feel} formalParameters={[]} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".function-expression")).toBeTruthy();
-    expect(container.querySelector(".function-expression table")).toBeTruthy();
-    expect(container.querySelector(".function-expression table thead")).toBeTruthy();
-    expect(container.querySelectorAll(".function-expression table thead tr")).toHaveLength(2);
-    expect(container.querySelectorAll(".function-expression table tbody tr")).toHaveLength(1);
-    expect(container.querySelectorAll(".function-expression table tbody td.data-cell")).toHaveLength(1);
-  });
-
-  test("should show a section in the header, with the list of parameters", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <FunctionExpression
-            logicType={LogicType.Function}
-            functionKind={FunctionKind.Feel}
-            formalParameters={[{ id: "p1", name: DEFAULT_FIRST_PARAM_NAME, dataType: DataType.Undefined }]}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".function-expression table thead .parameters-list")).toBeTruthy();
-    expect(container.querySelector(".function-expression table thead .parameters-list p")).toContainHTML(
-      `${DEFAULT_FIRST_PARAM_NAME}`
-    );
-  });
-
-  test("should reset function kind to FEEL, when resetting table row", async () => {
-    const mockedBroadcastDefinition = jest.fn();
-    mockBroadcastDefinition(mockedBroadcastDefinition);
-    const { container, baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Java} formalParameters={[]} />
-        ).wrapper
-      ).wrapper
-    );
-
-    await clearTableRow(container, baseElement);
-
-    expect(mockedBroadcastDefinition).toHaveBeenLastCalledWith({
-      dataType: DataType.Undefined,
-      expression: {
-        logicType: LogicType.LiteralExpression,
-      },
-      formalParameters: [],
-      functionKind: "FEEL",
-      logicType: "Function",
-      name: "p-1",
-      parametersWidth: 370,
-      id: undefined,
-    });
-  });
-
-  describe("Formal Parameters", () => {
-    beforeEach(() => {
-      jest.clearAllTimers();
-    });
-
-    test("should render no parameter, if passed property is empty array", async () => {
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Feel} formalParameters={[]} />
-          ).wrapper
-        ).wrapper
-      );
-      await activateSelector(container as HTMLElement, ".parameters-list");
-
-      expect(baseElement.querySelector(".parameters-editor")).toBeTruthy();
-      expect(baseElement.querySelector(".parameters-editor .parameters-container")).toBeTruthy();
-      expect(baseElement.querySelectorAll(".parameters-editor .parameters-container .parameter-entry")).toHaveLength(0);
-    });
-
-    test("should render all parameters, belonging to the passed property", async () => {
-      const paramName = "param";
-      const paramDataType = DataType.Any;
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Feel}
-              formalParameters={[{ id: parameterId, name: paramName, dataType: paramDataType }]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await activateSelector(container as HTMLElement, ".parameters-list");
-
-      expect(baseElement.querySelectorAll(".parameters-editor .parameters-container .parameter-entry")).toHaveLength(1);
-      expect((baseElement.querySelector(".parameter-name") as HTMLInputElement).value).toBe(paramName);
-      expect((baseElement.querySelector(EDIT_EXPRESSION_DATA_TYPE)! as HTMLInputElement).value).toBe(paramDataType);
-    });
-
-    test("should update the parameter name, when it gets changed by the user", async () => {
-      const newParamName = "new param";
-      const mockedBroadcastDefinition = jest.fn();
-      mockBroadcastDefinition(mockedBroadcastDefinition);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Feel}
-              formalParameters={[{ id: parameterId, name: "param", dataType: DataType.Any }]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await activateSelector(container as HTMLElement, ".parameters-list");
-      await act(async () => {
-        const input = baseElement.querySelector(".parameter-name") as HTMLInputElement;
-        fireEvent.blur(input, { target: { value: newParamName } });
-      });
-
-      checkFormalParameters(mockedBroadcastDefinition, [
-        {
-          id: parameterId,
-          dataType: DataType.Any,
-          name: `${newParamName}`,
-        },
-      ]);
-    });
-
-    test("should update the parameter data type, when it gets changed by the user", async () => {
-      const mockedBroadcastDefinition = jest.fn();
-      mockBroadcastDefinition(mockedBroadcastDefinition);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Feel}
-              formalParameters={[{ id: parameterId, name: "param", dataType: DataType.Undefined }]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await activateSelector(container as HTMLElement, ".parameters-list");
-      await act(async () => {
-        (
-          baseElement.querySelector("[data-ouia-component-id='edit-expression-data-type'] button") as HTMLButtonElement
-        ).click();
-        await flushPromises();
-        jest.runAllTimers();
-        (baseElement.querySelector(`[data-ouia-component-id='${DataType.Boolean}']`) as HTMLButtonElement).click();
-      });
-
-      checkFormalParameters(mockedBroadcastDefinition, [
-        {
-          id: parameterId,
-          dataType: DataType.Boolean,
-          name: "param",
-        },
-      ]);
-    });
-
-    test("should add a new parameter, when the user adds it", async () => {
-      const mockedBroadcastDefinition = jest.fn();
-      mockBroadcastDefinition(mockedBroadcastDefinition);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Feel} formalParameters={[]} />
-          ).wrapper
-        ).wrapper
-      );
-      await activateSelector(container as HTMLElement, ".parameters-list");
-      await act(async () => {
-        (baseElement.querySelector("button.add-parameter") as HTMLButtonElement).click();
-      });
-
-      checkFormalParameters(mockedBroadcastDefinition, [
-        expect.objectContaining({
-          dataType: DataType.Undefined,
-          name: DEFAULT_FIRST_PARAM_NAME,
-        }),
-      ]);
-    });
-
-    test("should have no parameter, when the user delete the only existing one", async () => {
-      const mockedBroadcastDefinition = jest.fn();
-      mockBroadcastDefinition(mockedBroadcastDefinition);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Feel}
-              formalParameters={[
-                {
-                  id: parameterId,
-                  dataType: DataType.Undefined,
-                  name: DEFAULT_FIRST_PARAM_NAME,
-                },
-              ]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await activateSelector(container as HTMLElement, ".parameters-list");
-      await act(async () => {
-        (baseElement.querySelector("button.delete-parameter") as HTMLButtonElement).click();
-      });
-
-      checkFormalParameters(mockedBroadcastDefinition, []);
-    });
-
-    function checkFormalParameters(mockedBroadcastDefinition: jest.Mock, formalParameters: EntryInfo[]) {
-      expect(mockedBroadcastDefinition).toHaveBeenCalledWith({
-        dataType: DataType.Undefined,
-        expression: {
-          logicType: "Literal expression",
-        },
-        formalParameters,
-        functionKind: "FEEL",
-        logicType: "Function",
-        name: "p-1",
-        parametersWidth: 370,
-        id: undefined,
-      });
-    }
-  });
-
-  describe("FEEL Function Kind", () => {
-    test("should show, by default, an entry with an empty literal expression", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Feel} formalParameters={[]} />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".function-expression table tbody td.data-cell")).toBeVisible();
-      expect(container.querySelector(".function-expression table tbody td.data-cell .literal-expression")).toBeTruthy();
-      expect(
-        (
-          container.querySelector(
-            ".function-expression table tbody td.data-cell .literal-expression textarea"
-          ) as HTMLTextAreaElement
-        ).value
-      ).toBe("");
-    });
-
-    test("should show an entry corresponding to the passed expression", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Feel}
-              formalParameters={[]}
-              expression={{
-                id: "id2",
-                logicType: LogicType.Relation,
-              }}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".function-expression table tbody td.data-cell")).toBeVisible();
-      expect(
-        container.querySelector(".function-expression table tbody td.data-cell .relation-expression")
-      ).toBeTruthy();
-      expect(
-        container.querySelector(".function-expression table tbody td.data-cell .relation-expression table")
-      ).toBeTruthy();
-    });
-  });
-
-  describe("JAVA Function Kind", () => {
-    test("should show, by default, an entry with a context table, containing two entries: class and method", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Java} formalParameters={[]} />
-          ).wrapper
-        ).wrapper
-      );
-
-      checkContextEntries(container, "class", "method");
-    });
-
-    test("should show an entry corresponding to the passed class and method values", () => {
-      const classValue = "class value";
-      const methodValue = "method value";
-
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Java}
-              formalParameters={[]}
-              className={classValue}
-              methodName={methodValue}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      checkContextEntries(container, classValue, methodValue, true);
-    });
-  });
-
-  describe("PMML Function Kind", () => {
-    test("should show, by default, an entry with a context table, containing two entries: document and model", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression logicType={LogicType.Function} functionKind={FunctionKind.Pmml} formalParameters={[]} />
-          ).wrapper
-        ).wrapper
-      );
-
-      checkContextEntries(container, "document", "model");
-    });
-
-    test("should show an entry corresponding to the passed document and model values", () => {
-      const document = "document";
-      const model = "model";
-
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <FunctionExpression
-              logicType={LogicType.Function}
-              functionKind={FunctionKind.Pmml}
-              formalParameters={[]}
-              document={document}
-              model={model}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      checkContextEntries(container, document, model, true);
-    });
-
-    test("should populate parameters list with parameters related to selected PMML model", async () => {
-      const mockedBroadcastDefinition = jest.fn();
-
-      let props: FunctionProps = {
-        logicType: LogicType.Function,
-        functionKind: FunctionKind.Pmml,
-        formalParameters: [],
-      };
-
-      const mockBroadcastDefinition = () => {
-        window.beeApi = _.extend(window.beeApi || {}, {
-          broadcastFunctionExpressionDefinition: (definition: FunctionProps) => {
-            props = {
-              ...props,
-              ...definition,
-            };
-            mockedBroadcastDefinition(definition);
-          },
-        });
-      };
-      mockBroadcastDefinition();
-
-      const screen = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(<FunctionExpression {...props} />).wrapper
-        ).wrapper
-      );
-
-      await act(async () => {
-        fireEvent.click(screen.container.querySelectorAll(".pmml-literal-expression button")[0]! as HTMLElement);
-        fireEvent.click(await screen.findByTestId("pmml-selector-document"));
-        fireEvent.click(await screen.findByTestId("pmml-document"));
-      });
-
-      screen.rerender(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(<FunctionExpression {...props} />).wrapper
-        ).wrapper
-      );
-      await act(async () => {
-        fireEvent.click(screen.container.querySelectorAll(".pmml-literal-expression button")[1]! as HTMLElement);
-        fireEvent.click(await screen.findByTestId("pmml-selector-model"));
-        fireEvent.click(await screen.findByTestId("pmml-model"));
-      });
-
-      expect(mockedBroadcastDefinition).toHaveBeenLastCalledWith(
-        expect.objectContaining({
-          document: documentName,
-          model: modelName,
-        })
-      );
-    });
-  });
-
-  function mockBroadcastDefinition(mockedBroadcastDefinition: jest.Mock) {
-    // noinspection JSVoidFunctionReturnValueUsed
-    window.beeApi = _.extend(window.beeApi || {}, {
-      broadcastFunctionExpressionDefinition: (definition: FunctionProps) => mockedBroadcastDefinition(definition),
-      notifyUserAction: () => {},
-    });
-  }
-
-  async function clearTableRow(container: Element, baseElement: Element) {
-    await act(async () => {
-      fireEvent.contextMenu(
-        container.querySelector(".function-expression table tbody td.counter-cell") as HTMLTableElement
-      );
-      await flushPromises();
-      jest.runAllTimers();
-    });
-
-    await act(async () => {
-      fireEvent.click(
-        baseElement.querySelector(
-          "[data-ouia-component-id='expression-table-handler-menu-Clear'] button"
-        )! as HTMLButtonElement
-      );
-      await flushPromises();
-      jest.runAllTimers();
-    });
-  }
-
-  function checkContextEntries(container: Element, firstEntry: string, secondEntry: string, checkExpression = false) {
-    const specificClassToCheck = checkExpression ? ".context-entry-expression-cell" : ".context-entry-info-cell";
-    const entriesSelector = `.function-expression table tbody td.data-cell .context-expression ${specificClassToCheck}`;
-
-    expect(container.querySelector(".function-expression table tbody td.data-cell")).toBeVisible();
-    expect(container.querySelector(".function-expression table tbody td.data-cell .context-expression")).toBeTruthy();
-    expect(container.querySelectorAll(entriesSelector)).toHaveLength(2);
-    expect(container.querySelectorAll(entriesSelector)[0]).toContainHTML(firstEntry);
-    expect(container.querySelectorAll(entriesSelector)[1]).toContainHTML(secondEntry);
-  }
-});
-
-jest.useFakeTimers();
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/FunctionExpression/FunctionKindSelector.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/FunctionExpression/FunctionKindSelector.test.tsx
deleted file mode 100644
index a61d46c..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/FunctionExpression/FunctionKindSelector.test.tsx
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { activateSelector, usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import * as React from "react";
-import { FunctionKindSelector } from "../../../components/FunctionExpression";
-import { FunctionKind } from "../../../api";
-import * as _ from "lodash";
-
-jest.useFakeTimers();
-
-describe("FunctionKindSelector tests", () => {
-  test("should render passed Function Kind property", async () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <FunctionKindSelector selectedFunctionKind={FunctionKind.Feel} onFunctionKindSelect={_.identity} />
-      ).wrapper
-    );
-
-    await activateSelector(container as HTMLElement, ".selected-function-kind");
-
-    expect(container.querySelector(".selected-function-kind")).toBeTruthy();
-    expect(container.querySelector(".selected-function-kind")).toContainHTML("F");
-  });
-
-  test("should trigger the Function Kind which the user has selected", async () => {
-    const onFunctionKindSelect = (functionKind: FunctionKind) => _.identity(functionKind);
-    const mockedFunctionKindSelect = jest.fn(onFunctionKindSelect);
-
-    const { container, baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <FunctionKindSelector
-          selectedFunctionKind={FunctionKind.Feel}
-          onFunctionKindSelect={mockedFunctionKindSelect}
-        />
-      ).wrapper
-    );
-
-    await activateSelector(container as HTMLElement, ".selected-function-kind");
-    await activateSelector(baseElement as HTMLElement, "[data-ouia-component-id='Java'] > button");
-
-    expect(mockedFunctionKindSelect).toHaveBeenCalled();
-    expect(mockedFunctionKindSelect).toHaveBeenCalledWith(FunctionKind.Java);
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/InvocationExpression/InvocationExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/InvocationExpression/InvocationExpression.test.tsx
deleted file mode 100644
index 560e72a..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/InvocationExpression/InvocationExpression.test.tsx
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../__mocks__/ReactWithSupervisor";
-import { render } from "@testing-library/react";
-import {
-  checkEntryContent,
-  contextEntry,
-  usingTestingBoxedExpressionI18nContext,
-  usingTestingBoxedExpressionProviderContext,
-} from "../test-utils";
-import { DataType, LogicType } from "../../../api";
-import * as React from "react";
-import { InvocationExpression } from "../../../components/InvocationExpression";
-
-describe("InvocationExpression tests", () => {
-  test("should show a table with two levels visible header, with one row and two columns", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<InvocationExpression logicType={LogicType.Invocation} />).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".invocation-expression")).toBeTruthy();
-    expect(container.querySelector(".invocation-expression table")).toBeTruthy();
-    expect(container.querySelector(".invocation-expression table thead")).toBeTruthy();
-    expect(container.querySelectorAll(".invocation-expression table thead tr")).toHaveLength(2);
-    expect(container.querySelectorAll(".invocation-expression table tbody tr")).toHaveLength(1);
-    expect(container.querySelectorAll(".invocation-expression table tbody td.data-cell")).toHaveLength(2);
-  });
-
-  test("should show a table with an input in the header, representing the invoked function", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<InvocationExpression logicType={LogicType.Invocation} />).wrapper
-      ).wrapper
-    );
-
-    expect(
-      container.querySelector(".invocation-expression table thead th .function-definition-container")
-    ).toBeTruthy();
-    expect(
-      container.querySelector(".invocation-expression table thead th .function-definition-container")
-    ).toContainHTML(
-      `<input class="function-definition pf-u-text-truncate" type="text" placeholder="Enter function" value="">`
-    );
-  });
-
-  test("should display the value of the passed invoked function", () => {
-    const invokedFunction = "Math.max";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <InvocationExpression logicType={LogicType.Invocation} invokedFunction={invokedFunction} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect((container.querySelector(".invocation-expression .function-definition") as HTMLInputElement).value).toBe(
-      invokedFunction
-    );
-  });
-
-  test("should display a row in the table body, for each given binding entries", () => {
-    const firstEntryId = "p1";
-    const firstEntryName = "param1";
-    const firstEntryDataType = DataType.Boolean;
-    const firstEntry = {
-      entryInfo: { id: firstEntryId, name: firstEntryName, dataType: firstEntryDataType },
-      entryExpression: {},
-      editInfoPopoverLabel: "Edit parameter",
-    };
-    const secondEntryId = "p2";
-    const secondEntryName = "param2";
-    const secondEntryDataType = DataType.Any;
-    const secondEntry = {
-      entryInfo: { id: secondEntryId, name: secondEntryName, dataType: secondEntryDataType },
-      entryExpression: {},
-      editInfoPopoverLabel: "Edit parameter",
-    };
-    const bindingEntries = [firstEntry, secondEntry];
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <InvocationExpression logicType={LogicType.Invocation} bindingEntries={bindingEntries} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".invocation-expression")).toBeTruthy();
-    expect(container.querySelectorAll(".invocation-expression table tbody tr")).toHaveLength(2);
-    checkEntryContent(contextEntry(container, 1), firstEntry.entryInfo);
-    checkEntryContent(contextEntry(container, 2), secondEntry.entryInfo);
-  });
-});
-
-jest.mock("../../../api", () => ({
-  ...(jest.requireActual("../../../api") as Record<string, unknown>),
-  getHandlerConfiguration: jest.fn(),
-}));
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/ListExpression/ListExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/ListExpression/ListExpression.test.tsx
deleted file mode 100644
index d14e16d..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/ListExpression/ListExpression.test.tsx
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../__mocks__/ReactWithSupervisor";
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext, usingTestingBoxedExpressionProviderContext } from "../test-utils";
-import { LogicType } from "../../../api";
-import * as React from "react";
-import { ListExpression } from "../../../components/ListExpression";
-
-describe("ListExpression tests", () => {
-  test("should show a table without header, with one row and one column", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<ListExpression logicType={LogicType.List} />).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".list-expression")).toBeTruthy();
-    expect(container.querySelector(".list-expression table")).toBeTruthy();
-    expect(container.querySelector(".list-expression table thead")).toBeNull();
-    expect(container.querySelectorAll(".list-expression table tbody tr")).toHaveLength(1);
-    expect(container.querySelectorAll(".list-expression table tbody td.data-cell")).toHaveLength(1);
-  });
-
-  test("should have, for its default cell, as default logic type, a literal expression with empty content", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(<ListExpression logicType={LogicType.List} />).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".list-expression table tbody td.data-cell .literal-expression")).toBeTruthy();
-    expect(
-      container.querySelector(
-        ".list-expression table tbody td.data-cell .literal-expression .literal-expression-body textarea"
-      )
-    ).toBeEmpty();
-  });
-
-  test("should be able to render nested expressions", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <ListExpression id="id1" logicType={LogicType.List} items={[{ logicType: LogicType.List, id: "id2" }]} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelectorAll(".list-expression")).toHaveLength(2);
-    expect(container.querySelector(".list-expression .table-component.id1 td.data-cell .list-expression")).toBeTruthy();
-    expect(
-      container.querySelector(
-        ".list-expression .table-component tbody td.data-cell .literal-expression .literal-expression-body textarea"
-      )
-    ).toBeEmpty();
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/LiteralExpression/LiteralExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/LiteralExpression/LiteralExpression.test.tsx
deleted file mode 100644
index bc77b8c..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/LiteralExpression/LiteralExpression.test.tsx
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext, usingTestingBoxedExpressionProviderContext } from "../test-utils";
-import * as React from "react";
-import { LiteralExpression } from "../../../components/LiteralExpression";
-import { DataType, LogicType } from "../../../api";
-import { act } from "react-dom/test-utils";
-
-jest.useFakeTimers();
-const flushPromises = () => new Promise((resolve) => process.nextTick(resolve));
-
-describe("LiteralExpression tests", () => {
-  describe("LiteralExpression Header", () => {
-    test("should render expression's name, when name property is passed", () => {
-      const expressionName = "expression name";
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression
-              logicType={LogicType.LiteralExpression}
-              name={expressionName}
-              dataType={DataType.Undefined}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      expect(container.querySelector(".expression-name")).toBeTruthy();
-      expect(container.querySelector(".expression-name")!.innerHTML).toBe(expressionName);
-    });
-
-    test("should render expression's data type, when dataType property is passed", () => {
-      const dataType = DataType.Boolean;
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression logicType={LogicType.LiteralExpression} name={"expressionName"} dataType={dataType} />
-          ).wrapper
-        ).wrapper
-      );
-      expect(container.querySelector(".expression-data-type")).toBeTruthy();
-      expect(container.querySelector(".expression-data-type")!.innerHTML).toBe("(" + dataType + ")");
-    });
-
-    test("should render no header section, when isHeadless property is passed", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression
-              isHeadless={true}
-              logicType={LogicType.LiteralExpression}
-              name={"expressionName"}
-              dataType={DataType.Undefined}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      expect(container.querySelector(".literal-expression-header")).toBeFalsy();
-    });
-
-    test("should render header section, when isHeadless property is not passed or it is false", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression
-              logicType={LogicType.LiteralExpression}
-              name={"expressionName"}
-              dataType={DataType.Undefined}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      expect(container.querySelector(".literal-expression-header")).toBeTruthy();
-    });
-
-    test("should render edit expression menu, when header is clicked", async () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression
-              logicType={LogicType.LiteralExpression}
-              name={"expressionName"}
-              dataType={DataType.Boolean}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      await act(async () => {
-        const literalExpressionHeader = container.querySelector(
-          ".literal-expression-header .expression-info"
-        )! as HTMLElement;
-        literalExpressionHeader.click();
-        await flushPromises();
-        jest.runAllTimers();
-      });
-
-      expect(document.querySelector(".selector-menu-title")).toBeTruthy();
-    });
-  });
-
-  describe("LiteralExpression Body", () => {
-    test("should render expression's content, when content property is passed", () => {
-      const content = "content";
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression
-              logicType={LogicType.LiteralExpression}
-              name={"expressionName"}
-              dataType={DataType.Boolean}
-              content={content}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".literal-expression-body textarea")).toBeTruthy();
-      expect(container.querySelector(".literal-expression-body textarea")!.innerHTML).toBe(content);
-    });
-
-    test("should render nothing, when content property is not passed", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <LiteralExpression
-              logicType={LogicType.LiteralExpression}
-              name={"expressionName"}
-              dataType={DataType.Boolean}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".literal-expression-body textarea")).toBeTruthy();
-      expect(container.querySelector(".literal-expression-body textarea")!.innerHTML).toBe("");
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/LogicTypeSelector/LogicTypeSelector.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/LogicTypeSelector/LogicTypeSelector.test.tsx
deleted file mode 100644
index e73ccea..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/LogicTypeSelector/LogicTypeSelector.test.tsx
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../__mocks__/ReactWithSupervisor";
-import { DataType, LogicType } from "../../../api";
-import { fireEvent, render } from "@testing-library/react";
-import {
-  flushPromises,
-  usingTestingBoxedExpressionI18nContext,
-  usingTestingBoxedExpressionProviderContext,
-} from "../test-utils";
-import { act } from "react-dom/test-utils";
-import * as React from "react";
-import { LogicTypeSelector } from "../../../components/LogicTypeSelector";
-import * as _ from "lodash";
-
-jest.useFakeTimers();
-
-describe("LogicTypeSelector tests", () => {
-  test("should have the clear action disabled on startup", async () => {
-    const expression = { name: "Test", dataType: DataType.Undefined };
-
-    const { baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <LogicTypeSelector
-            selectedExpression={expression}
-            getPlacementRef={() => document.body as HTMLDivElement}
-            onLogicTypeResetting={_.identity}
-            onLogicTypeUpdating={_.identity}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    await triggerContextMenu(baseElement as HTMLElement, ".logic-type-selector");
-
-    expect(baseElement.querySelector(".context-menu-container button")).toBeDisabled();
-    expect(baseElement.querySelector(".context-menu-container button")).toHaveTextContent("Clear");
-  });
-
-  test("should have the clear action enabled, when logic type is selected", async () => {
-    const expression = { name: "Test", logicType: LogicType.LiteralExpression, dataType: DataType.Undefined };
-
-    const { baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <LogicTypeSelector
-            selectedExpression={expression}
-            getPlacementRef={() => document.body as HTMLDivElement}
-            onLogicTypeResetting={_.identity}
-            onLogicTypeUpdating={_.identity}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    await triggerContextMenu(baseElement as HTMLElement, ".logic-type-selector");
-
-    expect(baseElement.querySelector(".context-menu-container button")).not.toBeDisabled();
-    expect(baseElement.querySelector(".context-menu-container button")).toBeTruthy();
-    expect(baseElement.querySelector(".context-menu-container button")).toHaveTextContent("Clear");
-  });
-});
-
-describe("Logic type selection", () => {
-  test("should show the pre-selection, when logic type prop is passed", () => {
-    const expression = { name: "Test", logicType: LogicType.List, dataType: DataType.Undefined };
-
-    const { baseElement } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <LogicTypeSelector
-            selectedExpression={expression}
-            getPlacementRef={() => document.body as HTMLDivElement}
-            onLogicTypeResetting={_.identity}
-            onLogicTypeUpdating={_.identity}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(baseElement.querySelector(".logic-type-selector")).toBeTruthy();
-    expect(baseElement.querySelector(".logic-type-selector")).toHaveClass("logic-type-selected");
-  });
-
-  test("should reset the selection, when logic type is selected and clear button gets clicked", async () => {
-    const expression = { name: "Test", logicType: LogicType.LiteralExpression, dataType: DataType.Undefined };
-    const onLogicTypeResetting = jest.fn().mockImplementation(() => {
-      expression.logicType = LogicType.Undefined;
-    });
-
-    const logicTypeSelector = usingTestingBoxedExpressionI18nContext(
-      usingTestingBoxedExpressionProviderContext(
-        <LogicTypeSelector
-          selectedExpression={expression}
-          getPlacementRef={() => document.body as HTMLDivElement}
-          onLogicTypeResetting={onLogicTypeResetting}
-          onLogicTypeUpdating={_.identity}
-        />
-      ).wrapper
-    ).wrapper;
-
-    const screen = render(logicTypeSelector);
-
-    await triggerContextMenu(screen.baseElement as HTMLElement, ".logic-type-selector");
-
-    act(() => {
-      const clearButtonElement = screen.baseElement.querySelector(".context-menu-container button")!;
-      const clearButton = clearButtonElement as HTMLButtonElement;
-      clearButton.click();
-    });
-
-    screen.rerender(logicTypeSelector);
-
-    expect(screen.baseElement.querySelector(".logic-type-selector")).toBeTruthy();
-    expect(screen.baseElement.querySelector(".logic-type-selector")).toHaveClass("logic-type-not-present");
-  });
-});
-
-const triggerContextMenu = async (container: HTMLElement, selector: string) => {
-  await act(async () => {
-    const element = container.querySelector(selector)!;
-    fireEvent.contextMenu(element);
-    await flushPromises();
-    jest.runAllTimers();
-  });
-};
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/PMMLLiteralExpression/PMMLLiteralExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/PMMLLiteralExpression/PMMLLiteralExpression.test.tsx
deleted file mode 100644
index 0d7548d..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/PMMLLiteralExpression/PMMLLiteralExpression.test.tsx
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { activateSelector, usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { LogicType } from "../../../api";
-import * as React from "react";
-import { PMMLLiteralExpression } from "../../../components/LiteralExpression";
-
-describe("PMMLLiteralExpression tests", () => {
-  test("should show noOptionsLabel when no options are available", async () => {
-    const noOptionsLabel = "no options label";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <PMMLLiteralExpression
-          logicType={LogicType.PMMLLiteralExpression}
-          getOptions={() => []}
-          noOptionsLabel={noOptionsLabel}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".pmml-literal-expression")).toBeTruthy();
-    expect(container.querySelector(".pmml-literal-expression button")).toContainHTML(noOptionsLabel);
-  });
-
-  test("should show noOptionsLabel when selected option is not present in the options list", async () => {
-    const noOptionsLabel = "no options label";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <PMMLLiteralExpression
-          logicType={LogicType.PMMLLiteralExpression}
-          getOptions={() => ["a", "b", "c"]}
-          selected="selected"
-          noOptionsLabel={noOptionsLabel}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".pmml-literal-expression")).toBeTruthy();
-    expect(container.querySelector(".pmml-literal-expression button")).toContainHTML(noOptionsLabel);
-  });
-
-  test("should show selected option when it is passed and it is present in the options list", async () => {
-    const selectedOption = "selected";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <PMMLLiteralExpression
-          logicType={LogicType.PMMLLiteralExpression}
-          getOptions={() => ["a", "b", "c", selectedOption]}
-          selected={selectedOption}
-          noOptionsLabel={"no options"}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector(".pmml-literal-expression")).toBeTruthy();
-    expect(container.querySelector(".pmml-literal-expression button")).toContainHTML(selectedOption);
-  });
-
-  test("should change the selected option when the user manually select it", async () => {
-    const changedOption = "changed";
-    const selectedOption = "selected";
-
-    const { baseElement, container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <PMMLLiteralExpression
-          logicType={LogicType.PMMLLiteralExpression}
-          getOptions={() => [changedOption, "a", "b", "c", selectedOption]}
-          selected={selectedOption}
-          noOptionsLabel={"no options"}
-        />
-      ).wrapper
-    );
-
-    await activateSelector(container as HTMLElement, ".pmml-literal-expression button");
-    (baseElement.querySelector(`[data-ouia-component-id='${changedOption}']`) as HTMLButtonElement).click();
-
-    expect(container.querySelector(".pmml-literal-expression")).toBeTruthy();
-    expect(container.querySelector(".pmml-literal-expression button")).toContainHTML(changedOption);
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/PopoverMenu/PopoverMenu.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/PopoverMenu/PopoverMenu.test.tsx
deleted file mode 100644
index 35679c7..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/PopoverMenu/PopoverMenu.test.tsx
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import * as React from "react";
-import { PopoverMenu } from "../../../components/PopoverMenu";
-import { act } from "react-dom/test-utils";
-
-jest.useFakeTimers();
-const flushPromises = () => new Promise((resolve) => process.nextTick(resolve));
-
-describe("PopoverMenu tests", () => {
-  test("should render PopoverMenu component", async () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <PopoverMenu
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            body={null}
-            title="title"
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container).toMatchSnapshot();
-  });
-
-  test("should render popover menu title, when title props is passed", async () => {
-    const title = "title";
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <div>
-          <div id="container">Popover</div>
-          <PopoverMenu
-            arrowPlacement={() => document.getElementById("container")!}
-            appendTo={() => document.getElementById("container")!}
-            body={null}
-            title={title}
-          />
-        </div>
-      ).wrapper
-    );
-
-    await activatePopover(container as HTMLElement);
-
-    expect(container.querySelector(".selector-menu-title")).toBeTruthy();
-    expect(container.querySelector(".selector-menu-title")!.innerHTML).toBe(title);
-  });
-});
-
-export async function activatePopover(container: HTMLElement): Promise<void> {
-  await act(async () => {
-    const popoverContainer = container.querySelector("#container")! as HTMLElement;
-    popoverContainer.click();
-    await flushPromises();
-    jest.runAllTimers();
-  });
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/PopoverMenu/__snapshots__/PopoverMenu.test.tsx.snap b/node_modules/boxed-expression-component/src/__tests__/components/PopoverMenu/__snapshots__/PopoverMenu.test.tsx.snap
deleted file mode 100644
index f4abeea..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/PopoverMenu/__snapshots__/PopoverMenu.test.tsx.snap
+++ /dev/null
@@ -1,72 +0,0 @@
-// Jest Snapshot v1, https://goo.gl/fbAQLP
-
-exports[`PopoverMenu tests should render PopoverMenu component 1`] = `
-<div>
-  <div>
-    <div
-      id="container"
-    >
-      Popover
-      <div
-        aria-describedby="popover-menu-selector-body"
-        aria-labelledby="popover-menu-selector-header"
-        aria-modal="true"
-        class="pf-c-popover popover-menu-selector pf-m-bottom"
-        data-ouia-component-id="expression-popover-menu"
-        data-popper-escaped="true"
-        data-popper-placement="bottom"
-        data-popper-reference-hidden="true"
-        role="dialog"
-        style="opacity: 1; transition: opacity 300ms cubic-bezier(.54, 1.5, .38, 1.11); position: absolute; left: 0px; top: 0px; z-index: 9999; transform: translate(0px, 0px);"
-      >
-        <div
-          class="pf-c-popover__arrow"
-        />
-        <div
-          class="pf-c-popover__content"
-        >
-          <button
-            aria-disabled="false"
-            aria-label="Close"
-            class="pf-c-button pf-m-plain"
-            data-ouia-component-id="OUIA-Generated-Button-plain-1"
-            data-ouia-component-type="PF4/Button"
-            data-ouia-safe="true"
-            style="pointer-events: auto;"
-            type="button"
-          >
-            <svg
-              aria-hidden="true"
-              fill="currentColor"
-              height="1em"
-              role="img"
-              style="vertical-align: -0.125em;"
-              viewBox="0 0 352 512"
-              width="1em"
-            >
-              <path
-                d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"
-              />
-            </svg>
-          </button>
-          <h6
-            class="pf-c-title pf-m-md"
-            id="popover-menu-selector-header"
-          >
-            <div
-              class="selector-menu-title"
-              data-ouia-component-id="expression-popover-menu-title"
-            >
-              title
-            </div>
-          </h6>
-          <div
-            class="pf-c-popover__body"
-            id="popover-menu-selector-body"
-          />
-        </div>
-      </div>
-    </div>
-  </div>
-</div>
-`;
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/RelationExpression/RelationExpression.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/RelationExpression/RelationExpression.test.tsx
deleted file mode 100644
index 0d8e295..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/RelationExpression/RelationExpression.test.tsx
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { Column, DataType, generateUuid, LogicType, Row } from "../../../api";
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext, usingTestingBoxedExpressionProviderContext } from "../test-utils";
-import * as React from "react";
-import { RelationExpression } from "../../../components/RelationExpression";
-
-describe("RelationExpression tests", () => {
-  test("should render a table element, with one default column and one default row, when no props are passed", () => {
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <RelationExpression logicType={LogicType.Relation} name="Relation" dataType={DataType.Undefined} />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".relation-expression")).toBeTruthy();
-    expect(container.querySelectorAll(".relation-expression table thead tr th")).toHaveLength(2);
-    expect(container.querySelectorAll(".relation-expression table thead tr th")[1].innerHTML).toContain("column-1");
-    expect(container.querySelectorAll(".relation-expression table tbody tr")).toHaveLength(1);
-  });
-
-  test("should render a table element, with one column, corresponding to passed prop", () => {
-    const columnName = "a column";
-    const columnDataType = DataType.Date;
-    const column = { id: generateUuid(), name: columnName, dataType: columnDataType };
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        usingTestingBoxedExpressionProviderContext(
-          <RelationExpression
-            logicType={LogicType.Relation}
-            name="Relation"
-            dataType={DataType.Undefined}
-            columns={[column]}
-          />
-        ).wrapper
-      ).wrapper
-    );
-
-    expect(container.querySelector(".relation-expression")).toBeTruthy();
-    expect(container.querySelectorAll(".relation-expression table thead tr th")).toHaveLength(2);
-    expect(container.querySelectorAll(".relation-expression table thead tr th")[1].innerHTML).toContain(columnName);
-    expect(container.querySelectorAll(".relation-expression table thead tr th")[1].innerHTML).toContain(columnDataType);
-  });
-
-  test("should render a table element, with one row, corresponding to passed prop", () => {
-    const columnName = "a column";
-    const column = { id: generateUuid(), name: columnName, dataType: DataType.Date };
-    const rowValue = "value";
-    const row: Row = { id: "row-id", cells: [rowValue] };
-
-    const container = buildRelationComponent(column, row);
-
-    expect(container.querySelector(".relation-expression")).toBeTruthy();
-    expect(container.querySelectorAll(".relation-expression table tbody tr")).toHaveLength(1);
-    expect(container.querySelectorAll(".relation-expression table tbody tr td")).toHaveLength(2);
-    expect(container.querySelectorAll(".relation-expression table tbody tr td")[1].innerHTML).toContain(rowValue);
-  });
-
-  test("should render a table element, where there is just one cell for each column", () => {
-    const columnName = "a column";
-    const column = { id: generateUuid(), name: columnName, dataType: DataType.Date };
-    const rowValue = "value";
-    const row: Row = { id: "row-id", cells: [rowValue, "another value", "and another one"] };
-
-    const container = buildRelationComponent(column, row);
-
-    expect(container.querySelector(".relation-expression")).toBeTruthy();
-    expect(container.querySelectorAll(".relation-expression table tbody tr")).toHaveLength(1);
-    expect(container.querySelectorAll(".relation-expression table tbody tr td")).toHaveLength(2);
-  });
-});
-
-function buildRelationComponent(column: Column, row: Row) {
-  const { container } = render(
-    usingTestingBoxedExpressionI18nContext(
-      usingTestingBoxedExpressionProviderContext(
-        <RelationExpression
-          logicType={LogicType.Relation}
-          name="Relation"
-          dataType={DataType.Undefined}
-          columns={[column]}
-          rows={[row]}
-        />
-      ).wrapper
-    ).wrapper
-  );
-  return container;
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/Resizer.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Resizer/Resizer.test.tsx
deleted file mode 100644
index 13ce334..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/Resizer.test.tsx
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../__mocks__/ReactWithSupervisor";
-import { fireEvent, render, waitFor } from "@testing-library/react";
-import * as React from "react";
-import { Resizer } from "../../../components/Resizer";
-import { wrapComponentInContext } from "../test-utils";
-
-describe("Resizer", () => {
-  describe("when users drag the draggable element", () => {
-    it("resizes the element", async () => {
-      const container = renderTable();
-      const draggable = container.querySelector(".col-2-3 .react-resizable .pf-c-drawer")!;
-      const resizable = container.querySelectorAll(".react-resizable")!;
-      const getWidth = (e: Node) => (e as HTMLElement).style.width;
-
-      fireEvent.mouseDown(draggable);
-      fireEvent.mouseMove(draggable, { clientX: 150 });
-      fireEvent.mouseUp(draggable);
-
-      await waitFor(() => {
-        expect(getWidth(resizable.item(0))).toBe("250px");
-        expect(getWidth(resizable.item(1))).toBe("250px");
-        expect(getWidth(resizable.item(2))).toBe("400px");
-        expect(getWidth(resizable.item(3))).toBe("250px");
-        expect(getWidth(resizable.item(4))).toBe("250px");
-        expect(getWidth(resizable.item(5))).toBe("400px");
-      });
-    });
-  });
-});
-
-function renderTable() {
-  return render(
-    wrapComponentInContext(
-      <>
-        <table>
-          <thead>
-            <tr>
-              <th className="col-1-1">
-                <Resizer width={250} />
-              </th>
-              <th className="col-1-2">
-                <Resizer width={250} />
-              </th>
-              <th className="col-1-3">
-                <Resizer width={250} />
-              </th>
-            </tr>
-          </thead>
-          <tbody>
-            <tr>
-              <td className="col-2-1">
-                <Resizer width={250} />
-              </td>
-              <td className="col-2-2">
-                <Resizer width={250} />
-              </td>
-              <td className="col-2-3">
-                <Resizer width={250} />
-              </td>
-            </tr>
-          </tbody>
-        </table>
-      </>
-    )
-  ).container;
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/Cell.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/Cell.test.tsx
deleted file mode 100644
index 6152087..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/Cell.test.tsx
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "../../../__mocks__/ReactWithSupervisor";
-import { Cell, CELL_CSS_SELECTOR } from "../../../../components/Resizer";
-import { Resizer } from "../../../../components/Resizer";
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext, wrapComponentInContext } from "../../test-utils";
-import * as React from "react";
-import { ContextExpression } from "../../../../components/ContextExpression";
-import { ContextProps } from "../../../../api";
-import { act } from "react-dom/test-utils";
-
-let cell: Cell;
-let element: HTMLElement;
-let container: Element;
-
-describe("Cell", () => {
-  beforeAll(() => {
-    document.body.dispatchEvent = jest.fn();
-  });
-
-  describe("getId", () => {
-    beforeEach(createLiteral);
-    it("returns the id present in the cell element", () => {
-      expect(cell.getId()).toBe("uuid-0000-1111-2222-3333");
-    });
-  });
-
-  describe("getRect", () => {
-    beforeEach(createLiteral);
-    it("returns the rect from the cell element", () => {
-      expect(cell.getRect()).toEqual(element.getBoundingClientRect());
-    });
-  });
-
-  describe("setWidth", () => {
-    beforeEach(createLiteral);
-
-    it("set the width in the element", () => {
-      act(() => cell.setWidth(150));
-      expect(element.style.width).toEqual("150px");
-      expect(document.body.dispatchEvent).toBeCalled();
-    });
-
-    it("set the width in the element considering the minimum value", () => {
-      act(() => cell.setWidth(80));
-      expect(element.style.width).toEqual("100px");
-      expect(document.body.dispatchEvent).toBeCalled();
-    });
-  });
-
-  describe("refreshWidthAsParent", () => {
-    it("set the width as parent", () => {
-      act(() => {
-        createContext();
-
-        const elements = container.querySelectorAll(CELL_CSS_SELECTOR);
-        const child1 = new Cell(elements.item(1) as HTMLElement, [], 1, document.body);
-        const child2 = new Cell(elements.item(2) as HTMLElement, [], 1, document.body);
-
-        element = elements.item(3) as HTMLElement;
-
-        cell = new Cell(element, [child1, child2], 0, document.body);
-
-        cell.refreshWidthAsParent();
-      });
-      expect(element.style.width).toBe("713px");
-    });
-  });
-
-  describe("refreshWidthAsLastColumn", () => {
-    it("set the width as the last column", () => {
-      act(() => {
-        createContext();
-
-        const elements = container.querySelectorAll(CELL_CSS_SELECTOR);
-        const child1 = new Cell(elements.item(0) as HTMLElement, [], 1, document.body);
-        const child2 = new Cell(elements.item(1) as HTMLElement, [], 1, document.body);
-
-        element = elements.item(2) as HTMLElement;
-        cell = new Cell(element, [child1, child2], 0, document.body);
-
-        cell.refreshWidthAsLastColumn();
-      });
-      expect(element.style.width).toBe("1468px");
-    });
-
-    it("does not change the width when it is not the last column", () => {
-      act(() => {
-        createLiteral();
-        cell.refreshWidthAsLastColumn();
-      });
-      expect(element.style.width).toBe("250px");
-    });
-  });
-
-  describe("isLastColumn", () => {
-    it("returns true when the literal expression lives in the last column", () => {
-      act(renderLiteralAtLastColumn);
-
-      expect(cell.isLastColumn()).toBeTruthy();
-    });
-
-    it("returns false when the literal expression does not live in the last column", () => {
-      act(renderLiteralAtRegularColumn);
-      expect(cell.isLastColumn()).toBeFalsy();
-    });
-  });
-});
-
-function renderLiteralAtRegularColumn() {
-  container = render(
-    usingTestingBoxedExpressionI18nContext(
-      wrapComponentInContext(
-        <>
-          <table>
-            <tbody>
-              <tr>
-                <td />
-                <td>
-                  <Resizer width={250} />
-                </td>
-                <td />
-              </tr>
-            </tbody>
-          </table>
-        </>
-      )
-    ).wrapper
-  ).container;
-  element = container.querySelector(CELL_CSS_SELECTOR) as HTMLElement;
-  cell = new Cell(element, [], 0, document.body);
-}
-
-function renderLiteralAtLastColumn() {
-  container = render(
-    usingTestingBoxedExpressionI18nContext(
-      wrapComponentInContext(
-        <>
-          <table>
-            <tbody>
-              <tr>
-                <td />
-                <td />
-                <td>
-                  <Resizer width={250} />
-                </td>
-              </tr>
-            </tbody>
-          </table>
-        </>
-      )
-    ).wrapper
-  ).container;
-  element = container.querySelector(CELL_CSS_SELECTOR) as HTMLElement;
-  cell = new Cell(element, [], 0, document.body);
-}
-
-function createLiteral() {
-  container = render(wrapComponentInContext(<Resizer width={250} />)).container;
-  element = container.querySelector(CELL_CSS_SELECTOR) as HTMLElement;
-  cell = new Cell(element, [], 0, document.body);
-}
-
-function createContext() {
-  container = render(
-    usingTestingBoxedExpressionI18nContext(
-      wrapComponentInContext(
-        <ContextExpression
-          {...({
-            id: "id1",
-            logicType: "Context",
-            name: "Expression Name",
-            dataType: "<Undefined>",
-            contextEntries: [
-              {
-                entryInfo: {
-                  name: "ContextEntry-1",
-                  dataType: "<Undefined>",
-                },
-                entryExpression: {
-                  id: "id2",
-                  logicType: "Context",
-                  contextEntries: [
-                    {
-                      entryInfo: {
-                        name: "ContextEntry-1",
-                        dataType: "<Undefined>",
-                      },
-                      entryExpression: {
-                        id: "id4",
-                        logicType: "Context",
-                        contextEntries: [
-                          {
-                            entryInfo: {
-                              name: "ContextEntry-1",
-                              dataType: "<Undefined>",
-                            },
-                            entryExpression: {},
-                            editInfoPopoverLabel: "Edit Context Entry",
-                          },
-                        ],
-                        result: {
-                          id: "id7",
-                        },
-                        entryInfoWidth: 257,
-                        entryExpressionWidth: 370,
-                      },
-                      editInfoPopoverLabel: "Edit Context Entry",
-                    },
-                  ],
-                  result: {
-                    id: "id5",
-                  },
-                  entryInfoWidth: 713,
-                  entryExpressionWidth: 691,
-                },
-                editInfoPopoverLabel: "Edit Context Entry",
-              },
-            ],
-            result: {
-              id: "id3",
-            },
-            entryInfoWidth: 150,
-            entryExpressionWidth: 1468,
-          } as unknown as ContextProps)}
-        />
-      )
-    ).wrapper
-  ).container;
-}
-
-jest.mock("uuid", () => {
-  return { v4: () => "0000-1111-2222-3333" };
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/DOMSession.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/DOMSession.test.tsx
deleted file mode 100644
index 7b29003..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/DOMSession.test.tsx
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import * as React from "react";
-import { Cell, DOMSession } from "../../../../components/Resizer";
-import { wrapComponentInContext } from "../../test-utils";
-
-describe("DOMSession", () => {
-  let session: DOMSession;
-  let cells: Cell[];
-
-  beforeEach(() => {
-    render(
-      wrapComponentInContext(
-        <>
-          <div data-test-id="cell-0" className="react-resizable">
-            <div data-test-id="cell-1" className="react-resizable">
-              <div data-test-id="cell-2" className="react-resizable" />
-              <div data-test-id="cell-3" className="react-resizable" />
-            </div>
-            <div data-test-id="cell-4" className="react-resizable" />
-          </div>
-          <div data-test-id="cell-5" className="react-resizable" />
-          <div data-test-id="cell-6" className="react-resizable" />
-        </>
-      )
-    );
-
-    session = new DOMSession(document.body);
-  });
-
-  describe("getCells", () => {
-    beforeEach(() => {
-      cells = session.getCells();
-    });
-
-    it("returns the cells with depth information", () => {
-      expect(cells[4].element.dataset.testId).toBe("cell-0");
-      expect(cells[4].depth).toBe(0);
-      expect(cells[5].element.dataset.testId).toBe("cell-5");
-      expect(cells[5].depth).toBe(0);
-      expect(cells[6].element.dataset.testId).toBe("cell-6");
-      expect(cells[6].depth).toBe(0);
-
-      expect(cells[2].element.dataset.testId).toBe("cell-1");
-      expect(cells[2].depth).toBe(1);
-      expect(cells[3].element.dataset.testId).toBe("cell-4");
-      expect(cells[3].depth).toBe(1);
-
-      expect(cells[0].element.dataset.testId).toBe("cell-2");
-      expect(cells[0].depth).toBe(2);
-      expect(cells[1].element.dataset.testId).toBe("cell-3");
-      expect(cells[1].depth).toBe(2);
-    });
-
-    it("returns the cells with children", () => {
-      expect(cells[0].children).toHaveLength(0);
-      expect(cells[1].children).toHaveLength(0);
-      expect(cells[2].children).toHaveLength(2);
-      expect(cells[3].children).toHaveLength(0);
-      expect(cells[4].children).toHaveLength(2);
-      expect(cells[5].children).toHaveLength(0);
-      expect(cells[6].children).toHaveLength(0);
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/ResizerSupervisorDOM.test.ts b/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/ResizerSupervisorDOM.test.ts
deleted file mode 100644
index 57a119a..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Resizer/dom/ResizerSupervisorDOM.test.ts
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { applyDOMSupervisor, Cell } from "../../../../components/Resizer";
-
-const fakeCells = [fakeCell(0), fakeCell(2), fakeCell(4), fakeCell(8)];
-
-describe("ResizerSupervisorDOM", () => {
-  describe("applyDOMSupervisor", () => {
-    beforeEach(() => {
-      applyDOMSupervisor(false, document.body);
-    });
-
-    it("refreshes cell widths as parents", () => {
-      expect(fakeCells[0].spyRefreshWidthAsParent).toBeCalled();
-      expect(fakeCells[1].spyRefreshWidthAsParent).toBeCalled();
-      expect(fakeCells[2].spyRefreshWidthAsParent).toBeCalled();
-      expect(fakeCells[3].spyRefreshWidthAsParent).toBeCalled();
-    });
-
-    it("refreshes cell widths as last column", () => {
-      expect(fakeCells[0].spyRefreshWidthAsLastColumn).toBeCalled();
-      expect(fakeCells[1].spyRefreshWidthAsLastColumn).toBeCalled();
-      expect(fakeCells[2].spyRefreshWidthAsLastColumn).toBeCalled();
-      expect(fakeCells[3].spyRefreshWidthAsLastColumn).toBeCalled();
-    });
-  });
-});
-
-jest.mock("src/components/Resizer/dom", () => {
-  const actualResizerDOM = jest.requireActual("src/components/Resizer/dom");
-  return {
-    ...actualResizerDOM,
-    DOMSession: jest.fn(() => ({
-      getCells: () => fakeCells.map((c) => c.cell),
-    })),
-    Cell: jest.fn(() => ({
-      refreshWidthAsParent: () => ({}),
-      refreshWidthAsLastColumn: () => ({}),
-      refreshWidthAsLastGroupColumn: () => ({}),
-    })),
-  };
-});
-
-function fakeCell(depth: number) {
-  const cell = new Cell({} as HTMLElement, [], depth, document.body);
-  const spyRefreshWidthAsParent = jest.spyOn(cell, "refreshWidthAsParent");
-  const spyRefreshWidthAsLastColumn = jest.spyOn(cell, "refreshWidthAsLastColumn");
-  return { cell, spyRefreshWidthAsParent, spyRefreshWidthAsLastColumn };
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/SelectionBox/CellSelectionBox.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/SelectionBox/CellSelectionBox.test.tsx
deleted file mode 100644
index e058830..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/SelectionBox/CellSelectionBox.test.tsx
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { fireEvent, render } from "@testing-library/react";
-import * as React from "react";
-import { CellSelectionBox } from "../../../components/SelectionBox";
-import "../../__mocks__/ReactWithSupervisor";
-import { wrapComponentInContext } from "../test-utils";
-
-describe("CellSelectionBox", () => {
-  describe("when users select elements", () => {
-    it("stores element values in the text area element", async () => {
-      const container = renderTable();
-
-      fireEvent.mouseDown(container, { clientX: -1, clientY: -1 });
-      fireEvent.mouseMove(container, { clientX: 1000, clientY: 1000 });
-      fireEvent.mouseUp(container);
-
-      const kieSelectionTextarea = container.querySelector(".kie-cell-selection-box textarea") as HTMLTextAreaElement;
-      const selectionValue = kieSelectionTextarea!.value;
-
-      expect(selectionValue).toMatch("Cell 1\tCell 2\tCell 3\tCell 4\tCell 5\tCell 6");
-    });
-  });
-});
-
-function renderTable() {
-  return render(
-    wrapComponentInContext(
-      <>
-        <CellSelectionBox />
-        <div className="uuid-f1f0b02e react-resizable">
-          <div className="editable-cell">
-            <textarea defaultValue="Cell 1" />
-          </div>
-        </div>
-        <div className="uuid-56cabb83 react-resizable">
-          <div className="editable-cell">
-            <textarea defaultValue="Cell 2" />
-          </div>
-        </div>
-        <div className="uuid-3daf1136 react-resizable">
-          <div className="editable-cell">
-            <textarea defaultValue="Cell 3" />
-          </div>
-        </div>
-        <div className="uuid-d45c5153 react-resizable">
-          <div className="editable-cell">
-            <textarea defaultValue="Cell 4" />
-          </div>
-        </div>
-        <div className="uuid-8265fa47 react-resizable">
-          <div className="editable-cell">
-            <textarea defaultValue="Cell 5" />
-          </div>
-        </div>
-        <div className="uuid-fb97017a react-resizable">
-          <div className="editable-cell">
-            <textarea defaultValue="Cell 6" />
-          </div>
-        </div>
-      </>
-    )
-  ).container;
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/SelectionBox/SelectionBox.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/SelectionBox/SelectionBox.test.tsx
deleted file mode 100644
index 997d454..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/SelectionBox/SelectionBox.test.tsx
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { fireEvent, render } from "@testing-library/react";
-import * as React from "react";
-import { Resizer } from "../../../components/Resizer";
-import { SelectionBox } from "../../../components/SelectionBox";
-import "../../__mocks__/ReactWithSupervisor";
-import { wrapComponentInContext } from "../test-utils";
-
-describe("SelectionBox", () => {
-  describe("when users drag the selection box element (but do not release the mouse button)", () => {
-    it("it appears in the screen", async () => {
-      const container = renderTable();
-      const selectionBox = container.querySelector(".kie-selection-box") as HTMLElement;
-      const selectionBoxStyle = selectionBox.style;
-
-      fireEvent.mouseDown(container, { clientX: 10, clientY: 20 });
-      fireEvent.mouseMove(container, { clientX: 300, clientY: 400 });
-
-      expect(selectionBoxStyle.width).toEqual("290px");
-      expect(selectionBoxStyle.height).toEqual("380px");
-      expect(selectionBoxStyle.top).toEqual("20px");
-      expect(selectionBoxStyle.left).toEqual("10px");
-    });
-  });
-
-  describe("when users drag the selection box element and release the mouse button", () => {
-    it("it doesn't appear in the screen", async () => {
-      const container = renderTable();
-      const selectionBox = container.querySelector(".kie-selection-box") as HTMLElement;
-      const selectionBoxStyle = selectionBox.style;
-
-      fireEvent.mouseDown(container, { clientX: 10, clientY: 10 });
-      fireEvent.mouseMove(container, { clientX: 300, clientY: 400 });
-      fireEvent.mouseUp(container);
-
-      expect(selectionBoxStyle.width).toEqual("");
-      expect(selectionBoxStyle.height).toEqual("");
-      expect(selectionBoxStyle.top).toEqual("");
-      expect(selectionBoxStyle.left).toEqual("");
-    });
-  });
-});
-
-function renderTable() {
-  return render(
-    wrapComponentInContext(
-      <>
-        <SelectionBox />
-        <table>
-          <thead>
-            <tr>
-              <th className="col-1-1">
-                <Resizer width={250} />
-              </th>
-              <th className="col-1-2">
-                <Resizer width={250} />
-              </th>
-              <th className="col-1-3">
-                <Resizer width={250} />
-              </th>
-            </tr>
-          </thead>
-          <tbody>
-            <tr>
-              <td className="col-2-1">
-                <Resizer width={250} />
-              </td>
-              <td className="col-2-2">
-                <Resizer width={250} />
-              </td>
-              <td className="col-2-3">
-                <Resizer width={250} />
-              </td>
-            </tr>
-          </tbody>
-        </table>
-      </>
-    )
-  ).container;
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Table/EditableCell.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Table/EditableCell.test.tsx
deleted file mode 100644
index 2d05d4a..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Table/EditableCell.test.tsx
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { act, fireEvent, render } from "@testing-library/react";
-import * as _ from "lodash";
-import * as React from "react";
-import { EditableCell, EDIT_MODE, READ_MODE } from "../../../components/Table";
-import { usingTestingBoxedExpressionI18nContext } from "../test-utils";
-
-describe("EditableCell", () => {
-  const CELL_SELECTOR = ".editable-cell";
-
-  let container: Element;
-
-  describe("when it renders", () => {
-    const initialValue = "INITIAL_VALUE";
-
-    beforeEach(() => {
-      container = render(
-        usingTestingBoxedExpressionI18nContext(
-          <EditableCell value={initialValue} rowIndex={0} columnId={"col1"} onCellUpdate={_.identity} />
-        ).wrapper
-      ).container;
-    });
-
-    test("renders the initial value", () => {
-      expect(container.querySelector("textarea")).toBeTruthy();
-      expect((container.querySelector("textarea") as HTMLTextAreaElement).value).toBe(initialValue);
-    });
-
-    test("renders on read mode", () => {
-      expect(container.querySelector(CELL_SELECTOR)?.classList.contains(READ_MODE)).toBeTruthy();
-    });
-  });
-
-  describe("when the user double-click on it", () => {
-    beforeEach(() => {
-      container = render(
-        usingTestingBoxedExpressionI18nContext(
-          <EditableCell value={"value"} rowIndex={0} columnId={"col1"} onCellUpdate={_.identity} />
-        ).wrapper
-      ).container;
-
-      fireEvent.doubleClick(container.querySelector(CELL_SELECTOR) as Element);
-    });
-
-    test("renders on edit mode", () => {
-      expect(container.querySelector(CELL_SELECTOR)?.classList.contains(EDIT_MODE)).toBeTruthy();
-    });
-  });
-
-  describe("when the user presses Enter with the cell selected", () => {
-    beforeEach(() => {
-      container = render(
-        usingTestingBoxedExpressionI18nContext(
-          <EditableCell value={"value"} rowIndex={0} columnId={"col1"} onCellUpdate={_.identity} />
-        ).wrapper
-      ).container;
-    });
-
-    test("renders on edit mode", () => {
-      fireEvent.click(container.querySelector(CELL_SELECTOR) as Element);
-      fireEvent.change(container.querySelector("textarea") as HTMLTextAreaElement, { target: { value: "Z" } });
-      expect(container.querySelector(CELL_SELECTOR)?.classList.contains(EDIT_MODE)).toBeTruthy();
-    });
-  });
-
-  describe("when the user click on it", () => {
-    beforeEach(() => {
-      container = render(
-        usingTestingBoxedExpressionI18nContext(
-          <EditableCell value={"value"} rowIndex={0} columnId={"col1"} onCellUpdate={_.identity} />
-        ).wrapper
-      ).container;
-
-      fireEvent.click(container.querySelector(CELL_SELECTOR) as Element);
-    });
-
-    test("focus on the text area", () => {
-      expect(document.querySelector("textarea")).toEqual(document.activeElement);
-    });
-
-    test("enable the selected style", () => {
-      expect(container.querySelector(CELL_SELECTOR)?.classList.contains("editable-cell--selected")).toBeTruthy();
-    });
-  });
-
-  describe("when the on blur events happens", () => {
-    const value = "value";
-    const newValue = "new value";
-    const rowIndex = 0;
-    const columnId = "col1";
-    const onCellUpdate = (rowIndex: number, columnId: string, value: string) => {
-      _.identity({ rowIndex, columnId, value });
-    };
-    const mockedOnCellUpdate = jest.fn(onCellUpdate);
-
-    test("triggers the onCellUpdate function", () => {
-      const { getByTestId } = render(
-        usingTestingBoxedExpressionI18nContext(
-          <EditableCell
-            value={value}
-            rowIndex={rowIndex}
-            columnId={columnId}
-            onCellUpdate={mockedOnCellUpdate}
-            readOnly={false}
-          />
-        ).wrapper
-      );
-
-      const textArea = getByTestId("editable-cell-textarea");
-      act(() => {
-        fireEvent.change(textArea, {
-          target: { value: `${newValue}` },
-        });
-      });
-
-      // triggers the textarea onChange method
-      expect(mockedOnCellUpdate).toHaveBeenCalled();
-      expect(mockedOnCellUpdate).toHaveBeenCalledWith(rowIndex, columnId, newValue);
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Table/Table.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Table/Table.test.tsx
deleted file mode 100644
index 2a9cdf6..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Table/Table.test.tsx
+++ /dev/null
@@ -1,665 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { fireEvent, render } from "@testing-library/react";
-import * as _ from "lodash";
-import * as React from "react";
-import { act } from "react-dom/test-utils";
-import { Column, ColumnInstance, DataRecord } from "react-table";
-import { PASTE_OPERATION } from "../../../components/Table/common";
-import { ColumnsUpdateArgs, DataType, RowsUpdateArgs, TableHandlerConfiguration, TableOperation } from "../../../api";
-import { Table } from "../../../components";
-import {
-  activateNameAndDataTypePopover,
-  EDIT_EXPRESSION_DATA_TYPE,
-  EDIT_EXPRESSION_NAME,
-  flushPromises,
-  updateElementViaPopover,
-  usingTestingBoxedExpressionI18nContext,
-  usingTestingBoxedExpressionProviderContext,
-  wrapComponentInContext,
-} from "../test-utils";
-import { DEFAULT_MIN_WIDTH } from "../../../components/Resizer";
-
-jest.useFakeTimers();
-
-const EXPRESSION_COLUMN_HEADER = "[data-ouia-component-type='expression-column-header']";
-const EXPRESSION_COLUMN_HEADER_CELL_INFO = "[data-ouia-component-type='expression-column-header-cell-info']";
-const EXPRESSION_POPOVER_MENU = "[data-ouia-component-id='expression-popover-menu']";
-const EXPRESSION_POPOVER_MENU_TITLE = "[data-ouia-component-id='expression-popover-menu-title']";
-const EXPRESSION_TABLE_HANDLER_MENU = "[data-ouia-component-id='expression-table-handler-menu']";
-const expressionRow = (index: number) => {
-  return "[data-ouia-component-id='expression-row-" + index + "']";
-};
-
-const expressionCell = (rowIndex: number, columnIndex: number) => {
-  return (
-    "[data-ouia-component-id='expression-row-" +
-    rowIndex +
-    "'] [data-ouia-component-id='expression-column-" +
-    columnIndex +
-    "']"
-  );
-};
-
-const expressionTableHandlerMenuEntry = (menuEntry: string) => {
-  return "[data-ouia-component-id='expression-table-handler-menu-" + menuEntry + "']";
-};
-
-const assertHeaderCell = (container: Element, expectedCells: number, content: string) => {
-  expect(container.querySelector(".table-component table thead")).toBeTruthy();
-  expect(container.querySelector(".table-component table thead tr")).toBeTruthy();
-  expect(container.querySelectorAll(EXPRESSION_COLUMN_HEADER).length).toBe(expectedCells);
-  expect(container.querySelectorAll(EXPRESSION_COLUMN_HEADER)[expectedCells - 1].innerHTML).toContain(content);
-};
-
-describe("Table tests", () => {
-  const columnName = "column-1";
-  const handlerConfiguration: TableHandlerConfiguration = [];
-
-  describe("when rendering it", () => {
-    test("should show a table element", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[]}
-              rows={[]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".table-component table")).toBeTruthy();
-    });
-
-    test("should show a table head with only one default column (#)", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[]}
-              rows={[]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      assertHeaderCell(container, 1, "#");
-    });
-
-    test("should show a table head with one configured column, rendering its label", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[{ accessor: columnName, label: columnName, dataType: DataType.Undefined } as ColumnInstance]}
-              rows={[]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      assertHeaderCell(container, 2, columnName);
-    });
-
-    test("should show a table head with one configured column, rendering its custom element", () => {
-      const customElementContent = "Custom Element";
-      const headerCellElement = <div>`${customElementContent}`</div>;
-
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[
-                {
-                  accessor: columnName,
-                  headerCellElement,
-                  dataType: DataType.Undefined,
-                } as ColumnInstance,
-              ]}
-              rows={[]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      assertHeaderCell(container, 2, customElementContent);
-    });
-
-    test("should show a table body with no rows", () => {
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[]}
-              rows={[]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".table-component table tbody")).toBeTruthy();
-      expect(container.querySelector(".table-component table tbody tr")).toBeFalsy();
-    });
-
-    test("should show a table body with one configured row", () => {
-      const row: DataRecord = {};
-      const cellValue = "cell value";
-      row[columnName] = cellValue;
-      const rows: DataRecord[] = [row];
-
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[{ accessor: columnName, dataType: DataType.Undefined } as ColumnInstance]}
-              rows={rows}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      expect(container.querySelector(".table-component table tbody")).toBeTruthy();
-      expect(container.querySelector(expressionRow(0))).toBeTruthy();
-      expect(container.querySelectorAll(expressionRow(0) + " td")).toHaveLength(2);
-      expect(container.querySelector(expressionCell(0, 0))!.innerHTML).toContain("1");
-      expect(container.querySelector(expressionCell(0, 1))!.innerHTML).toContain(cellValue);
-    });
-  });
-
-  describe("when interacting with header", () => {
-    test("should render popover with column name and dataType, when clicking on header cell", async () => {
-      const editRelationLabel = "Edit Relation";
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              editColumnLabel={editRelationLabel}
-              columns={[{ label: columnName, accessor: columnName, dataType: DataType.Boolean } as ColumnInstance]}
-              rows={[]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      await activateNameAndDataTypePopover(
-        container.querySelectorAll(EXPRESSION_COLUMN_HEADER_CELL_INFO)[0] as HTMLTableHeaderCellElement
-      );
-
-      expect(baseElement.querySelector(EXPRESSION_POPOVER_MENU)).toBeTruthy();
-      expect(baseElement.querySelector(EXPRESSION_POPOVER_MENU_TITLE)?.innerHTML).toBe(editRelationLabel);
-      expect((baseElement.querySelector(EDIT_EXPRESSION_NAME)! as HTMLInputElement).value).toBe(columnName);
-      expect((baseElement.querySelector(EDIT_EXPRESSION_DATA_TYPE)! as HTMLInputElement).value).toBe(DataType.Boolean);
-    });
-
-    test("should trigger onColumnUpdate, when changing column name via popover", async () => {
-      const columnId = "column-id";
-      const newColumnName = "changed";
-      const onColumnUpdate = ({ columns }: ColumnsUpdateArgs) => {
-        _.identity(columns);
-      };
-      const mockedOnColumnUpdate = jest.fn(onColumnUpdate);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[{ label: columnName, accessor: columnId, dataType: DataType.Boolean } as ColumnInstance]}
-              rows={[]}
-              onColumnsUpdate={mockedOnColumnUpdate}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await updateElementViaPopover(
-        container.querySelectorAll(EXPRESSION_COLUMN_HEADER_CELL_INFO)[0] as HTMLTableHeaderCellElement,
-        baseElement,
-        EDIT_EXPRESSION_NAME,
-        newColumnName
-      );
-
-      expect(mockedOnColumnUpdate).toHaveBeenCalled();
-      expect(mockedOnColumnUpdate).toHaveBeenCalledWith({
-        columns: [{ label: newColumnName, accessor: columnId, dataType: DataType.Boolean } as ColumnInstance],
-        columnIndex: 0,
-      });
-    });
-  });
-
-  describe("when interacting with body", () => {
-    test("should trigger onRowsUpdate, when changing cell value", async () => {
-      const row: DataRecord = {};
-      const newRow: DataRecord = {};
-      const rowValue = "value";
-      const newRowValue = "new value";
-      row[columnName] = rowValue;
-      newRow[columnName] = newRowValue;
-      const columns = [{ label: columnName, accessor: columnName, dataType: DataType.Boolean } as ColumnInstance];
-
-      row[columnName] = "value";
-      const orRowsUpdate = ({ rows }: RowsUpdateArgs) => {
-        _.identity(rows);
-      };
-      const mockedOnRowsUpdate = jest.fn(orRowsUpdate);
-
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={columns}
-              rows={[row]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={mockedOnRowsUpdate}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      const textarea = container.querySelector("table tbody tr td textarea") as HTMLTextAreaElement;
-
-      fireEvent.change(textarea, { target: { value: `${newRowValue}` } });
-      // onblur is triggered by Monaco (mock), and the new value relies on Monaco implementation
-
-      expect(mockedOnRowsUpdate).toHaveBeenCalled();
-      expect(mockedOnRowsUpdate).toHaveBeenCalledWith({
-        rows: [expect.objectContaining(newRow)],
-        columns,
-      });
-    });
-  });
-
-  describe("when users paste a value", () => {
-    test("should trigger onRowsUpdate", async () => {
-      const orRowsUpdate = ({ rows }: RowsUpdateArgs) => {
-        _.identity(rows);
-      };
-      const mockedOnRowsUpdate = jest.fn(orRowsUpdate);
-
-      const row: DataRecord = {};
-      const newRow: DataRecord = {};
-      const rowValue = "value";
-      const newRowValue = "new value";
-      row[columnName] = rowValue;
-      newRow[columnName] = newRowValue;
-
-      row[columnName] = "value";
-
-      const { container } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[{ label: columnName, accessor: columnName, dataType: DataType.Boolean } as ColumnInstance]}
-              rows={[row]}
-              onColumnsUpdate={_.identity}
-              onRowAdding={() => ({})}
-              onRowsUpdate={mockedOnRowsUpdate}
-              handlerConfiguration={handlerConfiguration}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      container.querySelector(".boxed-expression-provider")?.dispatchEvent(customEvent(container));
-      expect(mockedOnRowsUpdate).toHaveBeenCalled();
-    });
-  });
-
-  describe("when interacting with context menu", () => {
-    test("should trigger onColumnUpdate, when inserting a new column on the left", async () => {
-      const firstColumn = {
-        label: "column-2",
-        accessor: "column-2",
-        dataType: DataType.Undefined,
-        width: DEFAULT_MIN_WIDTH,
-      } as ColumnInstance;
-      const secondColumn = {
-        label: "column-3",
-        dataType: DataType.Undefined,
-        width: DEFAULT_MIN_WIDTH,
-      } as ColumnInstance;
-      const onColumnUpdate = ({ columns }: ColumnsUpdateArgs) => {
-        _.identity(columns);
-      };
-      const mockedOnColumnUpdate = jest.fn(onColumnUpdate);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[firstColumn]}
-              rows={[]}
-              onColumnsUpdate={mockedOnColumnUpdate}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={[
-                {
-                  group: "COLUMNS",
-                  items: [{ name: "Insert Column Left", type: TableOperation.ColumnInsertLeft }],
-                },
-              ]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await openContextMenu(container.querySelectorAll(EXPRESSION_COLUMN_HEADER)[1]);
-      await selectMenuEntryIfNotDisabled(baseElement, "Insert Column Left");
-
-      expect(mockedOnColumnUpdate).toHaveBeenCalledWith({
-        columns: [expect.objectContaining(secondColumn), firstColumn],
-        operation: TableOperation.ColumnInsertLeft,
-        columnIndex: 0,
-      });
-    });
-
-    test("should trigger onColumnUpdate, when inserting a new column on the right", async () => {
-      const firstColumn = {
-        label: "column-2",
-        accessor: "column-2",
-        dataType: DataType.Undefined,
-        width: DEFAULT_MIN_WIDTH,
-      } as ColumnInstance;
-      const secondColumn = {
-        label: "column-3",
-        dataType: DataType.Undefined,
-        width: DEFAULT_MIN_WIDTH,
-      } as ColumnInstance;
-      const onColumnUpdate = ({ columns }: ColumnsUpdateArgs) => {
-        _.identity(columns);
-      };
-      const mockedOnColumnUpdate = jest.fn(onColumnUpdate);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={[firstColumn]}
-              rows={[]}
-              onColumnsUpdate={mockedOnColumnUpdate}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={[
-                {
-                  group: "COLUMNS",
-                  items: [{ name: "Insert Column right", type: TableOperation.ColumnInsertRight }],
-                },
-              ]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await openContextMenu(container.querySelectorAll(EXPRESSION_COLUMN_HEADER)[1]);
-      await selectMenuEntryIfNotDisabled(baseElement, "Insert Column right");
-
-      expect(mockedOnColumnUpdate).toHaveBeenCalledWith({
-        columns: [firstColumn, expect.objectContaining(secondColumn)],
-        operation: TableOperation.ColumnInsertRight,
-        columnIndex: 0,
-      });
-    });
-
-    test("should trigger onColumnUpdate, when deleting a column", async () => {
-      const firstColumn = { label: "column-1", accessor: "column-1", dataType: DataType.Undefined } as ColumnInstance;
-      const secondColumn = { label: "column-2", accessor: "column-2", dataType: DataType.Undefined } as ColumnInstance;
-      const onColumnUpdate = ({ columns }: ColumnsUpdateArgs) => {
-        _.identity(columns);
-      };
-      const mockedOnColumnUpdate = jest.fn(onColumnUpdate);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          wrapComponentInContext(
-            <Table
-              columns={[firstColumn, secondColumn]}
-              rows={[]}
-              onColumnsUpdate={mockedOnColumnUpdate}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={[
-                {
-                  group: "COLUMNS",
-                  items: [{ name: "Delete", type: TableOperation.ColumnDelete }],
-                },
-              ]}
-            />
-          )
-        ).wrapper
-      );
-      await openContextMenu(container.querySelectorAll(EXPRESSION_COLUMN_HEADER)[1]);
-      await selectMenuEntryIfNotDisabled(baseElement, "Delete");
-
-      expect(mockedOnColumnUpdate).toHaveBeenCalledWith({
-        columns: [secondColumn],
-        operation: TableOperation.ColumnDelete,
-        columnIndex: 0,
-      });
-    });
-
-    test("should not trigger onColumnUpdate, when deleting a row number column", async () => {
-      const row: DataRecord = {};
-      row["#"] = "1";
-      row["column-1"] = "column-1 value";
-      row["column-2"] = "column-2 value";
-      const firstColumn = { label: "column-1", accessor: "column-1", dataType: DataType.Undefined } as ColumnInstance;
-      const secondColumn = { label: "column-2", accessor: "column-2", dataType: DataType.Undefined } as ColumnInstance;
-      const onColumnUpdate = ({ columns }: ColumnsUpdateArgs) => {
-        _.identity(columns);
-      };
-      const mockedOnColumnUpdate = jest.fn(onColumnUpdate);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          wrapComponentInContext(
-            <Table
-              columns={[firstColumn, secondColumn]}
-              rows={[row]}
-              onColumnsUpdate={mockedOnColumnUpdate}
-              onRowsUpdate={_.identity}
-              handlerConfiguration={[
-                {
-                  group: "COLUMNS",
-                  items: [{ name: "Delete", type: TableOperation.ColumnDelete }],
-                },
-              ]}
-            />
-          )
-        ).wrapper
-      );
-      await openContextMenu(container.querySelector(expressionCell(0, 0))!);
-      await selectMenuEntryIfNotDisabled(baseElement, "Delete");
-
-      expect(mockedOnColumnUpdate).toHaveBeenCalledTimes(0);
-    });
-
-    test("should trigger onRowsUpdate, when inserting a new row above", async () => {
-      const row: DataRecord = {};
-      row[columnName] = "value";
-      const columns = [{ label: columnName, accessor: columnName, dataType: DataType.Undefined } as ColumnInstance];
-      const onRowsUpdate = ({ rows }: RowsUpdateArgs) => {
-        _.identity(rows);
-      };
-      const mockedOnRowsUpdate = jest.fn(onRowsUpdate);
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={columns}
-              rows={[row]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={mockedOnRowsUpdate}
-              handlerConfiguration={[
-                {
-                  group: "ROWS",
-                  items: [{ name: "Insert row above", type: TableOperation.RowInsertAbove }],
-                },
-              ]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-
-      await openContextMenu(container.querySelector(expressionCell(0, 1))!);
-      await selectMenuEntryIfNotDisabled(baseElement, "Insert row above");
-
-      expect(mockedOnRowsUpdate).toHaveBeenCalledWith({
-        rows: [expect.objectContaining({ width: DEFAULT_MIN_WIDTH }), expect.objectContaining(row)],
-        operation: TableOperation.RowInsertAbove,
-        rowIndex: 0,
-        columns,
-      });
-    });
-
-    test("should trigger onRowsUpdate, when inserting a new row below", async () => {
-      const row: DataRecord = {};
-      row[columnName] = "value";
-      const onRowsUpdate = ({ rows }: RowsUpdateArgs) => {
-        _.identity(rows);
-      };
-      const mockedOnRowsUpdate = jest.fn(onRowsUpdate);
-      const columns = [{ label: columnName, accessor: columnName, dataType: DataType.Undefined } as ColumnInstance];
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={columns}
-              rows={[row]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={mockedOnRowsUpdate}
-              handlerConfiguration={[
-                {
-                  group: "ROWS",
-                  items: [{ name: "Insert row below", type: TableOperation.RowInsertBelow }],
-                },
-              ]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await openContextMenu(container.querySelector(expressionCell(0, 1))!);
-      await selectMenuEntryIfNotDisabled(baseElement, "Insert row below");
-
-      expect(mockedOnRowsUpdate).toHaveBeenCalledWith({
-        rows: [expect.objectContaining(row), expect.objectContaining({ width: DEFAULT_MIN_WIDTH })],
-        operation: TableOperation.RowInsertBelow,
-        rowIndex: 0,
-        columns,
-      });
-    });
-
-    test("should trigger onRowsUpdate, when deleting a row", async () => {
-      const firstRow: DataRecord = {};
-      const secondRow: DataRecord = {};
-      firstRow[columnName] = "value";
-      secondRow[columnName] = "another value";
-      const onRowsUpdate = ({ rows }: RowsUpdateArgs) => {
-        _.identity(rows);
-      };
-      const mockedOnRowsUpdate = jest.fn(onRowsUpdate);
-      const columns = [{ label: columnName, accessor: columnName, dataType: DataType.Undefined } as ColumnInstance];
-
-      const { container, baseElement } = render(
-        usingTestingBoxedExpressionI18nContext(
-          usingTestingBoxedExpressionProviderContext(
-            <Table
-              columns={columns}
-              rows={[firstRow, secondRow]}
-              onColumnsUpdate={_.identity}
-              onRowsUpdate={mockedOnRowsUpdate}
-              handlerConfiguration={[
-                {
-                  group: "ROWS",
-                  items: [{ name: "Delete", type: TableOperation.RowDelete }],
-                },
-              ]}
-            />
-          ).wrapper
-        ).wrapper
-      );
-      await openContextMenu(container.querySelector(expressionCell(0, 1))!);
-      await selectMenuEntryIfNotDisabled(baseElement, "Delete");
-
-      expect(mockedOnRowsUpdate).toHaveBeenCalledWith({
-        rows: [secondRow],
-        operation: TableOperation.RowDelete,
-        rowIndex: 0,
-        columns,
-      });
-    });
-  });
-});
-
-async function selectMenuEntryIfNotDisabled(baseElement: Element, menuEntry: string) {
-  await act(async () => {
-    expect(baseElement.querySelector(EXPRESSION_TABLE_HANDLER_MENU)).toBeTruthy();
-    const button: HTMLButtonElement = baseElement.querySelector(
-      expressionTableHandlerMenuEntry(menuEntry) + " button:not([disabled])"
-    ) as HTMLButtonElement;
-    if (button != null) {
-      button.click();
-    }
-    await flushPromises();
-    jest.runAllTimers();
-  });
-}
-
-export async function openContextMenu(element: Element): Promise<void> {
-  await act(async () => {
-    fireEvent.contextMenu(element);
-    await flushPromises();
-    jest.runAllTimers();
-  });
-}
-
-function customEvent(container: HTMLElement) {
-  const eventId: string =
-    _.first(
-      [].slice
-        .call(container.querySelector(".table-component")?.classList)
-        .filter((c: string) => c.match(/table-event-/g))
-    ) || "";
-
-  return new CustomEvent(eventId, {
-    detail: {
-      x: 0,
-      y: 0,
-      pasteValue: "A\tA\tA\n",
-      type: PASTE_OPERATION,
-    },
-  });
-}
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Table/TableHandlerMenu.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Table/TableHandlerMenu.test.tsx
deleted file mode 100644
index 4b00a5a..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Table/TableHandlerMenu.test.tsx
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import { usingTestingBoxedExpressionI18nContext } from "../test-utils";
-import { TableHandlerMenu } from "../../../components/Table";
-import * as React from "react";
-import { TableOperation } from "../../../api";
-import * as _ from "lodash";
-
-const menuItem = (item: string) => {
-  return "[data-ouia-component-id='expression-table-handler-menu-" + item + "'] span";
-};
-
-describe("TableHandlerMenu tests", () => {
-  test("should render the passed operations", () => {
-    const groupName = "a group";
-    const operationName = "insert left";
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <TableHandlerMenu
-          allowedOperations={[TableOperation.ColumnInsertLeft]}
-          handlerConfiguration={[
-            {
-              group: groupName,
-              items: [{ name: operationName, type: TableOperation.ColumnInsertLeft }],
-            },
-          ]}
-          onOperation={_.identity}
-        />
-      ).wrapper
-    );
-
-    expect(container.querySelector("div.table-handler-menu")).toBeTruthy();
-    expect(container.querySelector("h1.pf-c-menu__group-title")).toBeTruthy();
-    expect(container.querySelector("h1.pf-c-menu__group-title")!.innerHTML).toContain(groupName);
-    expect(container.querySelector(menuItem(operationName))).toBeTruthy();
-    expect(container.querySelector(menuItem(operationName))!.innerHTML).toContain(operationName);
-  });
-
-  test("should execute the clicked operation", () => {
-    const onOperation = (operation: TableOperation) => _.identity(operation);
-    const mockedOnOperation = jest.fn(onOperation);
-
-    const { container } = render(
-      usingTestingBoxedExpressionI18nContext(
-        <TableHandlerMenu
-          allowedOperations={[TableOperation.ColumnInsertLeft]}
-          handlerConfiguration={[
-            {
-              group: "a group",
-              items: [{ name: "insert left", type: TableOperation.ColumnInsertLeft }],
-            },
-          ]}
-          onOperation={mockedOnOperation}
-        />
-      ).wrapper
-    );
-
-    (container.querySelector(menuItem("insert left")) as HTMLSpanElement)!.click();
-    expect(mockedOnOperation).toHaveBeenCalled();
-    expect(mockedOnOperation).toHaveBeenCalledWith(TableOperation.ColumnInsertLeft);
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Table/common/CopyAndPasteUtils.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Table/common/CopyAndPasteUtils.test.tsx
deleted file mode 100644
index 12457b0..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Table/common/CopyAndPasteUtils.test.tsx
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import * as React from "react";
-import { act } from "react-dom/test-utils";
-import { DataRecord } from "react-table";
-import { iterableValue, paste, pasteOnTable } from "../../../../components/Table/common";
-import { wrapComponentInContext } from "../../test-utils";
-
-describe("CopyAndPasteUtils", () => {
-  describe("pasteOnTable", () => {
-    let rows: DataRecord[];
-    let rowFactory: () => DataRecord;
-
-    beforeEach(() => {
-      rows = [
-        { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-      ];
-
-      rowFactory = () => ({ "column-1": "-", "column-2": "-", "column-3": "-" });
-    });
-
-    describe("when the paste value is empty", () => {
-      test("returns a new instance of rows with updated values", () => {
-        let newRows;
-
-        act(() => {
-          newRows = pasteOnTable("", rows, rowFactory);
-        });
-
-        expect(newRows).not.toBe(rows);
-        expect(newRows).toEqual([
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        ]);
-      });
-    });
-
-    describe("when the paste value has a single row", () => {
-      test("returns a new instance of rows with updated values", () => {
-        let newRows;
-
-        act(() => {
-          newRows = pasteOnTable("aaaa\tbbbb", rows, rowFactory);
-        });
-
-        expect(newRows).not.toBe(rows);
-        expect(newRows).toEqual([
-          { "column-1": "aaaa", "column-2": "bbbb", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        ]);
-      });
-    });
-
-    describe("when the paste value has multiple rows", () => {
-      test("returns a new instance of rows with updated values", () => {
-        let newRows;
-
-        act(() => {
-          newRows = pasteOnTable("aaaa\tbbbb\ncccc\tdddd", rows, rowFactory);
-        });
-
-        expect(newRows).not.toBe(rows);
-        expect(newRows).toEqual([
-          { "column-1": "aaaa", "column-2": "bbbb", "column-3": "0000" },
-          { "column-1": "cccc", "column-2": "dddd", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        ]);
-      });
-    });
-
-    describe("when the paste value has multiple rows and a custom initial coordinate", () => {
-      test("returns a new instance of rows with updated values", () => {
-        let newRows;
-
-        act(() => {
-          newRows = pasteOnTable("aaaa\tbbbb\ncccc\tdddd", rows, rowFactory, 1, 1);
-        });
-
-        expect(newRows).not.toBe(rows);
-        expect(newRows).toEqual([
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "aaaa", "column-3": "bbbb" },
-          { "column-1": "0000", "column-2": "cccc", "column-3": "dddd" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        ]);
-      });
-    });
-
-    describe("when the paste value has multiple rows with extra reserved chars", () => {
-      test("returns a new instance of rows with updated values", () => {
-        let newRows;
-
-        act(() => {
-          newRows = pasteOnTable("aaaa\tbbbb\t\ncccc\tdddd\n", rows, rowFactory);
-        });
-
-        expect(newRows).not.toBe(rows);
-        expect(newRows).toEqual([
-          { "column-1": "aaaa", "column-2": "bbbb", "column-3": "0000" },
-          { "column-1": "cccc", "column-2": "dddd", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-          { "column-1": "0000", "column-2": "0000", "column-3": "0000" },
-        ]);
-      });
-    });
-  });
-
-  describe("iterableValue", () => {
-    describe("when the paste value is empty", () => {
-      test("returns an iterable data structure", () => {
-        expect(iterableValue("")).toEqual([[]]);
-      });
-    });
-
-    describe("when the paste value has a single row", () => {
-      test("returns an iterable data structure", () => {
-        expect(iterableValue("A\tB\tC")).toEqual([["A", "B", "C"]]);
-      });
-    });
-
-    describe("when the paste value has multiple rows", () => {
-      test("returns an iterable data structure", () => {
-        expect(iterableValue("A\tB\tC\nD\tE\tF")).toEqual([
-          ["A", "B", "C"],
-          ["D", "E", "F"],
-        ]);
-      });
-    });
-  });
-
-  describe("paste", () => {
-    beforeEach(() => {
-      document.body.dispatchEvent = jest.fn();
-
-      const container = render(
-        wrapComponentInContext(
-          <>
-            <table className="table-component table-event-0">
-              <tbody>
-                <tr>
-                  <td>A</td>
-                  <td>B</td>
-                  <td>C</td>
-                </tr>
-                <tr>
-                  <td>D</td>
-                  <td className="ref">E</td>
-                  <td>F</td>
-                </tr>
-                <tr>
-                  <td>G</td>
-                  <td>H</td>
-                  <td>I</td>
-                </tr>
-              </tbody>
-            </table>
-          </>
-        )
-      ).container;
-
-      paste("Z\tZ\nZ\tZ", container.querySelector(".ref")!, document.body);
-    });
-
-    test("dispatches paste event", () => {
-      expect(document.body.dispatchEvent).toBeCalled();
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/Table/common/TableUtils.test.tsx b/node_modules/boxed-expression-component/src/__tests__/components/Table/common/TableUtils.test.tsx
deleted file mode 100644
index 4dd7042..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/Table/common/TableUtils.test.tsx
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright 2021 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import { render } from "@testing-library/react";
-import * as React from "react";
-import { getCellCoordinates, getCellTableId } from "../../../../components/Table/common";
-
-describe("TableUtils", () => {
-  describe("getCellCoordinates", () => {
-    let container: Element;
-    let cells: NodeListOf<Element>;
-    beforeEach(() => {
-      document.dispatchEvent = jest.fn();
-
-      container = render(
-        <>
-          <table className="table-component table-event-0">
-            <tbody>
-              <tr>
-                <td className="data-cell">A</td>
-                <td className="data-cell">B</td>
-                <td className="data-cell">C</td>
-              </tr>
-              <tr>
-                <td className="data-cell">D</td>
-                <td className="data-cell">E</td>
-                <td className="data-cell">F</td>
-              </tr>
-            </tbody>
-          </table>
-        </>
-      ).container;
-
-      cells = container.querySelectorAll(".data-cell");
-    });
-
-    test("valid coordinates", () => {
-      expect(getCellCoordinates(cells[0])).toEqual({
-        x: 0,
-        y: 0,
-      });
-      expect(getCellCoordinates(cells[1])).toEqual({
-        x: 1,
-        y: 0,
-      });
-      expect(getCellCoordinates(cells[2])).toEqual({
-        x: 2,
-        y: 0,
-      });
-
-      expect(getCellCoordinates(cells[3])).toEqual({
-        x: 0,
-        y: 1,
-      });
-      expect(getCellCoordinates(cells[4])).toEqual({
-        x: 1,
-        y: 1,
-      });
-      expect(getCellCoordinates(cells[5])).toEqual({
-        x: 2,
-        y: 1,
-      });
-      expect(getCellCoordinates(null)).toEqual({
-        x: 0,
-        y: 0,
-      });
-    });
-  });
-
-  describe("getCellTableId", () => {
-    let container: Element;
-    let cells: NodeListOf<Element>;
-    beforeEach(() => {
-      document.dispatchEvent = jest.fn();
-
-      container = render(
-        <>
-          <table className="table-component table-event-0">
-            <tbody>
-              <tr>
-                <td className="data-cell">A</td>
-                <td className="data-cell">B</td>
-                <td className="data-cell">C</td>
-              </tr>
-              <tr>
-                <td className="data-cell">D</td>
-                <td className="data-cell">E</td>
-                <td className="data-cell">F</td>
-              </tr>
-            </tbody>
-          </table>
-        </>
-      ).container;
-
-      cells = container.querySelectorAll(".data-cell");
-    });
-
-    test("dispatches paste event", () => {
-      expect(getCellTableId(cells[0])).toEqual("table-event-0");
-    });
-  });
-});
diff --git a/node_modules/boxed-expression-component/src/__tests__/components/test-utils.tsx b/node_modules/boxed-expression-component/src/__tests__/components/test-utils.tsx
deleted file mode 100644
index ed391e7..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/components/test-utils.tsx
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import * as React from "react";
-import { I18nDictionariesProvider, I18nDictionariesProviderProps } from "@kogito-tooling/i18n/dist/react-components";
-import {
-  boxedExpressionEditorDictionaries,
-  BoxedExpressionEditorI18n,
-  BoxedExpressionEditorI18nContext,
-  boxedExpressionEditorI18nDefaults,
-} from "../../i18n";
-import { act } from "react-dom/test-utils";
-import { fireEvent } from "@testing-library/react";
-import { BoxedExpressionGlobalContext } from "../../context";
-import { DataType } from "../../api";
-import { BoxedExpressionProvider, BoxedExpressionProviderProps } from "../../components";
-
-global.console = { ...global.console, warn: jest.fn() };
-
-export const EDIT_EXPRESSION_NAME = "[data-ouia-component-id='edit-expression-name']";
-export const EDIT_EXPRESSION_DATA_TYPE = "[data-ouia-component-id='edit-expression-data-type'] input";
-
-export const flushPromises: () => Promise<unknown> = () => new Promise((resolve) => process.nextTick(resolve));
-
-// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
-export function usingTestingBoxedExpressionI18nContext(
-  children: React.ReactElement,
-  ctx?: Partial<I18nDictionariesProviderProps<BoxedExpressionEditorI18n>>
-) {
-  const usedCtx: I18nDictionariesProviderProps<BoxedExpressionEditorI18n> = {
-    defaults: boxedExpressionEditorI18nDefaults,
-    dictionaries: boxedExpressionEditorDictionaries,
-    ctx: BoxedExpressionEditorI18nContext,
-    children,
-    ...ctx,
-  };
-  return {
-    ctx: usedCtx,
-    wrapper: (
-      <I18nDictionariesProvider defaults={usedCtx.defaults} dictionaries={usedCtx.dictionaries} ctx={usedCtx.ctx}>
-        {usedCtx.children}
-      </I18nDictionariesProvider>
-    ),
-  };
-}
-
-export function usingTestingBoxedExpressionProviderContext(
-  children: React.ReactElement,
-  ctx?: Partial<BoxedExpressionProviderProps>
-) {
-  const usedCtx: BoxedExpressionProviderProps = {
-    decisionNodeId: "_00000000-0000-0000-0000-000000000000",
-    expressionDefinition: {},
-    pmmlParams: [
-      {
-        document: "document",
-        modelsFromDocument: [
-          { model: "model", parametersFromModel: [{ id: "p1", name: "p-1", dataType: DataType.Number }] },
-        ],
-      },
-    ],
-    isRunnerTable: false,
-    children,
-    ...ctx,
-  };
-  return {
-    ctx: usedCtx,
-    wrapper: (
-      <BoxedExpressionProvider
-        decisionNodeId={usedCtx.decisionNodeId}
-        expressionDefinition={usedCtx.expressionDefinition}
-        pmmlParams={usedCtx.pmmlParams}
-        isRunnerTable={false}
-      >
-        {usedCtx.children}
-      </BoxedExpressionProvider>
-    ),
-  };
-}
-
-export function wrapComponentInContext(component: JSX.Element): JSX.Element {
-  return (
-    <BoxedExpressionGlobalContext.Provider
-      value={{
-        decisionNodeId: "_00000000-0000-0000-0000-000000000000",
-        pmmlParams: [
-          {
-            document: "document",
-            modelsFromDocument: [
-              { model: "model", parametersFromModel: [{ id: "p1", name: "p-1", dataType: DataType.Number }] },
-            ],
-          },
-        ],
-        supervisorHash: "",
-        setSupervisorHash: jest.fn,
-        editorRef: { current: document.body as HTMLDivElement },
-        currentlyOpenedHandlerCallback: jest.fn,
-        setCurrentlyOpenedHandlerCallback: jest.fn,
-      }}
-    >
-      {component}
-    </BoxedExpressionGlobalContext.Provider>
-  );
-}
-
-export async function activateSelector(container: HTMLElement, query: string): Promise<void> {
-  await act(async () => {
-    const selector = container.querySelector(query)! as HTMLElement;
-    selector.click();
-    await flushPromises();
-    jest.runAllTimers();
-  });
-}
-
-export async function activateNameAndDataTypePopover(element: HTMLElement): Promise<void> {
-  await act(async () => {
-    element.click();
-    await flushPromises();
-    jest.runAllTimers();
-  });
-}
-
-export async function updateElementViaPopover(
-  /** Element that when clicked will trigger the popover */
-  triggerPoint: HTMLElement,
-  /** Base container used as reference for the test */
-  baseElement: Element,
-  /** Selector used for get the input element */
-  inputSelector: string,
-  /** New value passed to the input element */
-  newName: string
-): Promise<void> {
-  await activateNameAndDataTypePopover(triggerPoint);
-  const inputElement = baseElement.querySelector(inputSelector)! as HTMLInputElement;
-  inputElement.value = newName;
-  await act(async () => {
-    fireEvent.change(inputElement, {
-      target: { value: newName },
-    });
-    await flushPromises();
-    jest.runAllTimers();
-  });
-  await act(async () => {
-    fireEvent.blur(inputElement);
-    await flushPromises();
-    jest.runAllTimers();
-  });
-}
-
-export const contextEntry = (container: Element, index: number): Element | null =>
-  container.querySelector(`table tbody tr:nth-of-type(${index})`);
-
-export const checkEntryContent = (
-  entry: Element | null,
-  entryRecordInfo: { id?: string; name: string; dataType: string }
-): void => {
-  if (entryRecordInfo.id) {
-    expect(entry?.querySelector(".entry-info")).toHaveClass(entryRecordInfo.id);
-  }
-  expect(entry).toContainHTML(entryRecordInfo.name);
-  expect(entry).toContainHTML(entryRecordInfo.dataType);
-};
-
-export const checkEntryStyle = (entry: Element | null, cssClass: string): void => {
-  expect(entry?.querySelector(".entry-expression")?.firstChild).toHaveClass(cssClass);
-};
-
-export const checkEntryLogicType = (entry: Element | null, cssClass: string): void => {
-  expect(entry?.querySelector(".entry-expression")?.firstChild?.firstChild).toHaveClass(cssClass);
-};
diff --git a/node_modules/boxed-expression-component/src/__tests__/test-setup.ts b/node_modules/boxed-expression-component/src/__tests__/test-setup.ts
deleted file mode 100644
index 8880774..0000000
--- a/node_modules/boxed-expression-component/src/__tests__/test-setup.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright 2020 Red Hat, Inc. and/or its affiliates.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import "jest-extended";
-import "jest-webextension-mock";
-import "@testing-library/jest-dom";
diff --git a/node_modules/boxed-expression-component/src/components/BoxedExpressionEditor/BoxedExpressionEditor.tsx b/node_modules/boxed-expression-component/src/components/BoxedExpressionEditor/BoxedExpressionEditor.tsx
index 634cf3f..e5a2b3b 100644
--- a/node_modules/boxed-expression-component/src/components/BoxedExpressionEditor/BoxedExpressionEditor.tsx
+++ b/node_modules/boxed-expression-component/src/components/BoxedExpressionEditor/BoxedExpressionEditor.tsx
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import { I18nDictionariesProvider } from "@kogito-tooling/i18n/dist/react-components";
+import { I18nDictionariesProvider } from "@kie-tooling-core/i18n/dist/react-components";
 import * as React from "react";
 import { useCallback, useEffect, useMemo, useState } from "react";
 import { ExpressionProps, PMMLParams } from "../../api";
diff --git a/node_modules/boxed-expression-component/src/components/Table/EditableCell.tsx b/node_modules/boxed-expression-component/src/components/Table/EditableCell.tsx
index 20c33ce..b994f17 100644
--- a/node_modules/boxed-expression-component/src/components/Table/EditableCell.tsx
+++ b/node_modules/boxed-expression-component/src/components/Table/EditableCell.tsx
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-import { FeelInput, FeelInputRef } from "feel-input-component";
-import * as Monaco from "monaco-editor";
+import { FeelInput, FeelInputRef } from "@kogito-tooling/feel-input-component";
+import * as Monaco from "@kie-tooling-core/monaco-editor";
 import "monaco-editor/dev/vs/editor/editor.main.css";
 import * as React from "react";
 import { useCallback, useEffect, useMemo, useRef, useState } from "react";
diff --git a/node_modules/boxed-expression-component/src/i18n/BoxedExpressionEditorI18n.ts b/node_modules/boxed-expression-component/src/i18n/BoxedExpressionEditorI18n.ts
index d019c88..2b8aa20 100644
--- a/node_modules/boxed-expression-component/src/i18n/BoxedExpressionEditorI18n.ts
+++ b/node_modules/boxed-expression-component/src/i18n/BoxedExpressionEditorI18n.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import { ReferenceDictionary } from "@kogito-tooling/i18n/dist/core";
+import { ReferenceDictionary } from "@kie-tooling-core/i18n/dist/core";
 import { CommonI18n } from "@kogito-tooling/i18n-common-dictionary";
 
 interface BoxedExpressionEditorDictionary extends ReferenceDictionary {
diff --git a/node_modules/boxed-expression-component/src/i18n/setup.ts b/node_modules/boxed-expression-component/src/i18n/setup.ts
index dafd832..690e0af 100644
--- a/node_modules/boxed-expression-component/src/i18n/setup.ts
+++ b/node_modules/boxed-expression-component/src/i18n/setup.ts
@@ -17,9 +17,9 @@
 import * as React from "react";
 import { useContext } from "react";
 import { en } from "./locales";
-import { I18nContextType } from "@kogito-tooling/i18n/dist/react-components";
+import { I18nContextType } from "@kie-tooling-core/i18n/dist/react-components";
 import { BoxedExpressionEditorI18n } from "./BoxedExpressionEditorI18n";
-import { I18nDefaults, I18nDictionaries } from "@kogito-tooling/i18n/dist/core";
+import { I18nDefaults, I18nDictionaries } from "@kie-tooling-core/i18n/dist/core";
 
 export const boxedExpressionEditorI18nDefaults: I18nDefaults<BoxedExpressionEditorI18n> = {
   locale: "en",
