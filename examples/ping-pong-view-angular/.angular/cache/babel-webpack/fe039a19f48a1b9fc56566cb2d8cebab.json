{
  "ast": null,
  "code": "import { OperatorSubscriber } from './OperatorSubscriber';\nexport function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {\n  return function (source, subscriber) {\n    var hasState = hasSeed;\n    var state = seed;\n    var index = 0;\n    source.subscribe(new OperatorSubscriber(subscriber, function (value) {\n      var i = index++;\n      state = hasState ? accumulator(state, value, i) : (hasState = true, value);\n      emitOnNext && subscriber.next(state);\n    }, emitBeforeComplete && function () {\n      hasState && subscriber.next(state);\n      subscriber.complete();\n    }));\n  };\n}",
  "map": {
    "version": 3,
    "sources": [
      "/home/koda/redhat/kogito-tooling/examples/ping-pong-view-angular/node_modules/rxjs/dist/esm/internal/operators/scanInternals.js"
    ],
    "names": [
      "OperatorSubscriber",
      "scanInternals",
      "accumulator",
      "seed",
      "hasSeed",
      "emitOnNext",
      "emitBeforeComplete",
      "source",
      "subscriber",
      "hasState",
      "state",
      "index",
      "subscribe",
      "value",
      "i",
      "next",
      "complete"
    ],
    "mappings": "AAAA,SAASA,kBAAT,QAAmC,sBAAnC;AACA,OAAO,SAASC,aAAT,CAAuBC,WAAvB,EAAoCC,IAApC,EAA0CC,OAA1C,EAAmDC,UAAnD,EAA+DC,kBAA/D,EAAmF;AACtF,SAAO,UAACC,MAAD,EAASC,UAAT,EAAwB;AAC3B,QAAIC,QAAQ,GAAGL,OAAf;AACA,QAAIM,KAAK,GAAGP,IAAZ;AACA,QAAIQ,KAAK,GAAG,CAAZ;AACAJ,IAAAA,MAAM,CAACK,SAAP,CAAiB,IAAIZ,kBAAJ,CAAuBQ,UAAvB,EAAmC,UAACK,KAAD,EAAW;AAC3D,UAAMC,CAAC,GAAGH,KAAK,EAAf;AACAD,MAAAA,KAAK,GAAGD,QAAQ,GAERP,WAAW,CAACQ,KAAD,EAAQG,KAAR,EAAeC,CAAf,CAFH,IAINL,QAAQ,GAAG,IAAZ,EAAmBI,KAJZ,CAAhB;AAKAR,MAAAA,UAAU,IAAIG,UAAU,CAACO,IAAX,CAAgBL,KAAhB,CAAd;AACH,KARgB,EAQdJ,kBAAkB,IAChB,YAAM;AACHG,MAAAA,QAAQ,IAAID,UAAU,CAACO,IAAX,CAAgBL,KAAhB,CAAZ;AACAF,MAAAA,UAAU,CAACQ,QAAX;AACH,KAZY,CAAjB;AAaH,GAjBD;AAkBH",
    "sourcesContent": [
      "import { OperatorSubscriber } from './OperatorSubscriber';\nexport function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {\n    return (source, subscriber) => {\n        let hasState = hasSeed;\n        let state = seed;\n        let index = 0;\n        source.subscribe(new OperatorSubscriber(subscriber, (value) => {\n            const i = index++;\n            state = hasState\n                ?\n                    accumulator(state, value, i)\n                :\n                    ((hasState = true), value);\n            emitOnNext && subscriber.next(state);\n        }, emitBeforeComplete &&\n            (() => {\n                hasState && subscriber.next(state);\n                subscriber.complete();\n            })));\n    };\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
