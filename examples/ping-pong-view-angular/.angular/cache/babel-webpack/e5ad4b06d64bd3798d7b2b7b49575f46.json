{
  "ast": null,
  "code": "import _createForOfIteratorHelper from \"/home/koda/redhat/kogito-tooling/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { OperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function bufferTime(bufferTimeSpan) {\n  var _a, _b;\n\n  for (var _len = arguments.length, otherArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    otherArgs[_key - 1] = arguments[_key];\n  }\n\n  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;\n  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;\n  var maxBufferSize = otherArgs[1] || Infinity;\n  return operate(function (source, subscriber) {\n    var bufferRecords = [];\n    var restartOnEmit = false;\n\n    var emit = function emit(record) {\n      var buffer = record.buffer,\n          subs = record.subs;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    var startBuffer = function startBuffer() {\n      if (bufferRecords) {\n        var subs = new Subscription();\n        subscriber.add(subs);\n        var buffer = [];\n        var record = {\n          buffer: buffer,\n          subs: subs\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, function () {\n          return emit(record);\n        }, bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n    var bufferTimeSubscriber = new OperatorSubscriber(subscriber, function (value) {\n      var recordsCopy = bufferRecords.slice();\n\n      var _iterator = _createForOfIteratorHelper(recordsCopy),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var record = _step.value;\n          var buffer = record.buffer;\n          buffer.push(value);\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }, function () {\n      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {\n        subscriber.next(bufferRecords.shift().buffer);\n      }\n\n      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();\n      subscriber.complete();\n      subscriber.unsubscribe();\n    }, undefined, function () {\n      return bufferRecords = null;\n    });\n    source.subscribe(bufferTimeSubscriber);\n  });\n} //# sourceMappingURL=bufferTime.js.map",
  "map": null,
  "metadata": {},
  "sourceType": "module"
}
