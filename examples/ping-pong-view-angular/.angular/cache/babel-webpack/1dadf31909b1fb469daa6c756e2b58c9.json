{
  "ast": null,
  "code": "import _toConsumableArray from \"/home/koda/redhat/kogito-tooling/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\nexport function zip() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var resultSelector = popResultSelector(args);\n  var sources = argsOrArgArray(args);\n  return sources.length ? new Observable(function (subscriber) {\n    var buffers = sources.map(function () {\n      return [];\n    });\n    var completed = sources.map(function () {\n      return false;\n    });\n    subscriber.add(function () {\n      buffers = completed = null;\n    });\n\n    var _loop = function _loop(sourceIndex) {\n      innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, function (value) {\n        buffers[sourceIndex].push(value);\n\n        if (buffers.every(function (buffer) {\n          return buffer.length;\n        })) {\n          var result = buffers.map(function (buffer) {\n            return buffer.shift();\n          });\n          subscriber.next(resultSelector ? resultSelector.apply(void 0, _toConsumableArray(result)) : result);\n\n          if (buffers.some(function (buffer, i) {\n            return !buffer.length && completed[i];\n          })) {\n            subscriber.complete();\n          }\n        }\n      }, function () {\n        completed[sourceIndex] = true;\n        !buffers[sourceIndex].length && subscriber.complete();\n      }));\n    };\n\n    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n      _loop(sourceIndex);\n    }\n\n    return function () {\n      buffers = completed = null;\n    };\n  }) : EMPTY;\n}",
  "map": {
    "version": 3,
    "sources": [
      "/home/koda/redhat/kogito-tooling/examples/ping-pong-view-angular/node_modules/rxjs/dist/esm/internal/observable/zip.js"
    ],
    "names": [
      "Observable",
      "innerFrom",
      "argsOrArgArray",
      "EMPTY",
      "OperatorSubscriber",
      "popResultSelector",
      "zip",
      "args",
      "resultSelector",
      "sources",
      "length",
      "subscriber",
      "buffers",
      "map",
      "completed",
      "add",
      "sourceIndex",
      "subscribe",
      "value",
      "push",
      "every",
      "buffer",
      "result",
      "shift",
      "next",
      "some",
      "i",
      "complete",
      "closed"
    ],
    "mappings": ";AAAA,SAASA,UAAT,QAA2B,eAA3B;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,cAAT,QAA+B,wBAA/B;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,kBAAT,QAAmC,iCAAnC;AACA,SAASC,iBAAT,QAAkC,cAAlC;AACA,OAAO,SAASC,GAAT,GAAsB;AAAA,oCAANC,IAAM;AAANA,IAAAA,IAAM;AAAA;;AACzB,MAAMC,cAAc,GAAGH,iBAAiB,CAACE,IAAD,CAAxC;AACA,MAAME,OAAO,GAAGP,cAAc,CAACK,IAAD,CAA9B;AACA,SAAOE,OAAO,CAACC,MAAR,GACD,IAAIV,UAAJ,CAAe,UAACW,UAAD,EAAgB;AAC7B,QAAIC,OAAO,GAAGH,OAAO,CAACI,GAAR,CAAY;AAAA,aAAM,EAAN;AAAA,KAAZ,CAAd;AACA,QAAIC,SAAS,GAAGL,OAAO,CAACI,GAAR,CAAY;AAAA,aAAM,KAAN;AAAA,KAAZ,CAAhB;AACAF,IAAAA,UAAU,CAACI,GAAX,CAAe,YAAM;AACjBH,MAAAA,OAAO,GAAGE,SAAS,GAAG,IAAtB;AACH,KAFD;;AAH6B,+BAMpBE,WANoB;AAOzBf,MAAAA,SAAS,CAACQ,OAAO,CAACO,WAAD,CAAR,CAAT,CAAgCC,SAAhC,CAA0C,IAAIb,kBAAJ,CAAuBO,UAAvB,EAAmC,UAACO,KAAD,EAAW;AACpFN,QAAAA,OAAO,CAACI,WAAD,CAAP,CAAqBG,IAArB,CAA0BD,KAA1B;;AACA,YAAIN,OAAO,CAACQ,KAAR,CAAc,UAACC,MAAD;AAAA,iBAAYA,MAAM,CAACX,MAAnB;AAAA,SAAd,CAAJ,EAA8C;AAC1C,cAAMY,MAAM,GAAGV,OAAO,CAACC,GAAR,CAAY,UAACQ,MAAD;AAAA,mBAAYA,MAAM,CAACE,KAAP,EAAZ;AAAA,WAAZ,CAAf;AACAZ,UAAAA,UAAU,CAACa,IAAX,CAAgBhB,cAAc,GAAGA,cAAc,MAAd,4BAAkBc,MAAlB,EAAH,GAA+BA,MAA7D;;AACA,cAAIV,OAAO,CAACa,IAAR,CAAa,UAACJ,MAAD,EAASK,CAAT;AAAA,mBAAe,CAACL,MAAM,CAACX,MAAR,IAAkBI,SAAS,CAACY,CAAD,CAA1C;AAAA,WAAb,CAAJ,EAAiE;AAC7Df,YAAAA,UAAU,CAACgB,QAAX;AACH;AACJ;AACJ,OATyC,EASvC,YAAM;AACLb,QAAAA,SAAS,CAACE,WAAD,CAAT,GAAyB,IAAzB;AACA,SAACJ,OAAO,CAACI,WAAD,CAAP,CAAqBN,MAAtB,IAAgCC,UAAU,CAACgB,QAAX,EAAhC;AACH,OAZyC,CAA1C;AAPyB;;AAM7B,SAAK,IAAIX,WAAW,GAAG,CAAvB,EAA0B,CAACL,UAAU,CAACiB,MAAZ,IAAsBZ,WAAW,GAAGP,OAAO,CAACC,MAAtE,EAA8EM,WAAW,EAAzF,EAA6F;AAAA,YAApFA,WAAoF;AAc5F;;AACD,WAAO,YAAM;AACTJ,MAAAA,OAAO,GAAGE,SAAS,GAAG,IAAtB;AACH,KAFD;AAGH,GAxBC,CADC,GA0BDX,KA1BN;AA2BH",
    "sourcesContent": [
      "import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\nexport function zip(...args) {\n    const resultSelector = popResultSelector(args);\n    const sources = argsOrArgArray(args);\n    return sources.length\n        ? new Observable((subscriber) => {\n            let buffers = sources.map(() => []);\n            let completed = sources.map(() => false);\n            subscriber.add(() => {\n                buffers = completed = null;\n            });\n            for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n                innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, (value) => {\n                    buffers[sourceIndex].push(value);\n                    if (buffers.every((buffer) => buffer.length)) {\n                        const result = buffers.map((buffer) => buffer.shift());\n                        subscriber.next(resultSelector ? resultSelector(...result) : result);\n                        if (buffers.some((buffer, i) => !buffer.length && completed[i])) {\n                            subscriber.complete();\n                        }\n                    }\n                }, () => {\n                    completed[sourceIndex] = true;\n                    !buffers[sourceIndex].length && subscriber.complete();\n                }));\n            }\n            return () => {\n                buffers = completed = null;\n            };\n        })\n        : EMPTY;\n}\n"
    ]
  },
  "metadata": {},
  "sourceType": "module"
}
