= Getting Acquainted With UberFire
Jonathan Fuerth <jfuerth@redhat.com>
:toc:
:source-highlighter: highlightjs
:stylesheet: asciidoctor.css
:link-suffix: .asciidoc

This guide will walk you through the process of setting up a new
UberFire application. Starting from an empty directory, you will
create a Maven `pom.xml` file to describe your project and its
dependencies, build up a simple application with client-side and
server-side behaviour, and learn how everything works along the way.

If you've never seen a full-blown working UberFire app before, why not
check out our link:quick-start{link-suffix}[Quick Start Guide] first?
It will help you get UberFire's pre-made showcase application up and
running on your system without getting bogged down in details.

This in-depth guide will be here waiting for you when you're ready to
scratch the surface and build something of your own.

So, assuming you're already familiar with what UberFire can do, let's
get started!

== Prerequisites

This guide assumes you have the following software set up and working
on your computer:

* http://www.oracle.com/technetwork/java/javase/downloads/index.html[A
  Java Development Kit (JDK) version 6 or newer]
* http://maven.apache.org/download.cgi[Maven 3.x]
* http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/keplersr1[Eclipse IDE for Java EE Developers]
  Kepler SR1 or newer, or whatever Java IDE you like better (NetBeans,
  IntelliJ IDEA)

== Layout of a Typical UberFire Project

Your UberFire project will follow the standard Maven project
layout. Most open source Java projects follow this layout these days,
so this should look familiar. Here's a rundown of the specific files
and directories you'll find in every UberFire project. Don't get hung
up on the details yet. We'll get to each of these in turn.

pom.xml::
 Maven build configuration. Tells Maven and Java IDEs how to build
 your project.
src/main/java/::
 Java sources for both the server-side and client-side go here,
 organized into subdirectories by package, just like all Java
 projects require.
src/main/java/__com/mycompany/uftutorial__/UberFireTutorial.gwt.xml::
 GWT module declaration. Specifies GWT dependencies, which packages
 contain code destined for the client side, and (optionally) more.
src/main/java/__com/mycompany/uftutorial__/client/::
 Java package containing code that will be compiled to JavaScript (as
 configured in the `UberFireTutorial.gwt.xml` module descriptor) but
 not deployed in the WAR file (as configured in the `pom.xml`).
src/main/java/__com/mycompany/uftutorial__/client/css/::
 Stylesheets referred to by Errai UI's HTML templates. Will be copied
 into the webapp during the build.
src/main/java/__com/mycompany/uftutorial__/server/::
 Java package for code that will be deployed to the server but not
 compiled to JavaScript.
src/main/java/__com/mycompany/uftutorial__/shared/::
 Java package for code that will be deployed to the server _and_
 compiled to JavaScript for the client. Typically business model
 classes and event classes go in the shared package.
src/main/resources/::
 Normal Maven project location for resources that should be on the
 classpath. In GWT projects (which means UberFire projects too),
 `src/main/java` and `src/main/resources` are both defined as resource
 paths, so it's up to you whether you put resources here or under
 `src/main/java`.
src/main/resources/app.html.template::
 FreeMarker template that contains the `<script>` tag that loads your
 GWT application code. It's translated to HTML on demand by
 `UberFireServlet`, and its as-served static contents are what your
 users will see while the JavaScript code that makes up your real
 application is downloading.

 TODO: Why FreeMarker? Why not an Errai UI Template, a static HTML
 file, or even a JSP?
src/main/resources/ErraiApp.properties::
 Marker file for the Errai framework. Errai uses this file to discover
 classpath locations that need to be scanned for Errai-annotated
 classes.  It's usually an empty file, but there are a number of
 https://docs.jboss.org/author/display/ERRAI/ErraiApp.properties[Errai
 framework settings] that can be placed here if necessary.
src/main/resources/log4j.properties::
 Standard log4j configuration file. You can use any logging framework
 with UberFire, but in this tutorial we're using log4j.
src/main/resources/login.config::
 JAAS configuration file that specifies which login module the
 application is using.
src/main/resources/users.properties::
 List of application users and their roles. This is processed by
 UberFire's PropertyUserSource, so if you are using a different source
 of user and role information, your app won't need one of these.
src/main/resources/url_filter.yaml::
 List of URL patterns that are only accessible to authenticated users
 who belong to certain roles. Also lists public resources that are
 always served to any user. Processed by UberFire's
 URLResourceManager, which is used by UberFireSecurityFilter to
 control access to protected resources.

 TODO: Why YAML? Why not web.xml security constraints?
src/main/resources/META-INF/services/::
 Standard directory where Java extensions are configured.
src/main/resources/META-INF/services/javax.enterprise.inject.spi.Extension::
 The list of CDI Portable Extensions provided by the UberFire
 framework. Affects the discovery and behaviour of server-side CDI
 beans.

 TODO: these should be declared in UberFire jars, not by the apps themselves.
src/main/resources/META-INF/services/org.uberfire.java.nio.file.spi.FileSystemProvider::
 The list of UberFire virtual filesystem (VFS) providers used in the
 application, one per line. Each entry is the fully-qualified name of
 a Java class that implements UberFire's `FileSystemProvider`
 interface. The first VFS provider listed is the default.
src/main/resources/META-INF/services/org.uberfire.security.auth.AuthenticationSource::
 The list of classes UberFire can use to authenticate login requests.
 Each line is the fully-qualified name of a Java class that implements
 UberFire's `AuthenticationSource` interface.
src/main/resources/org/uberfire/public/::
 All the files under this resource folder will be copied into a
 publicly accessible location within the web application. The default
 `app.html.template` file references images and CSS stored here.

 TODO: find out what causes these to be copied into the webapp!
src/main/webapp/::
 The standard root directory for resources that will be bundled in the
 WAR file in a Maven-built web app project.
src/main/webapp/login.html::
 UberFire apps typically have a dedicated login page separate from the
 GWT application. This is that page.

 TODO: why couldn't the login be served by UberFireServlet instead, in
 the same way the host page is served?

src/main/webapp/WEB-INF/::
 The standard directory where Java EE deployment descriptors, compiled
 Java classes, and third-party libraries go. You can also put your
 application's own non-public files under this directory. Files under
 this directory can be read by server-side code at runtime, but cannot
 be accessed by direct HTTP requests.
src/main/webapp/WEB-INF/beans.xml::
 Marker file for CDI. The existence of this file declares that the web
 application is CDI-enabled. The `beans.xml` file is left empty in
 simply CDI applications, but in UberFire applications, `beans.xml`
 normally defines some CDI interceptors that help enforce security
 rules.
src/main/webapp/WEB-INF/web.xml::
 Standard Java Servlets deployment descriptor. Defines the UberFire
 servlet, the UberFire security filter, and the Errai Servlet in
 addition to any servlets, security rules, and configuration required
 by your application's own code.

 TODO: we can eliminate the need for this file by annotating
 UberFireServlet and UberFireSecurityFilter appropriately.
target/::
 Maven build steps write their output here. This directory and all its
 contents are completely removed whenever you execute `mvn clean`.

== Create an empty project in your IDE

Now that you've got an idea of what we're aiming for, let's get
started by creating a new project in your IDE of choice. This guide
provides instructions that were tested on Eclipse Kepler SR1, but if
you're comfortable in a different IDE, follow along and perform
similar steps in your own IDE.

1. Create a new Maven project using the *File -> New Maven Project...*
   menu. The ``New Maven Project'' wizard will appear.

2. Ensure the checkbox *Create a simple project (skip archetype
   selection)* is checked. Choose whatever location and working set
   you like, then press *Next*.

3. Enter the following values in the Artifact section of the form:
+
[horizontal]
Group Id::
  Anything you like. For example, *com.mycompany.uftutorial*
Artifact Id::
  Anything you like. For example, *uberfire-tutorial*
Version::
  Anything you like, as long as it ends in ``-SNAPSHOT''. For example, *0.0.1-SNAPSHOT*
Packaging::
  *war*
Name::
  Anything you like. For example, *UberFire Tutorial Project*.
Description::
  Anything you like. For example, *A project I'm creating from
  scratch in order to learn UberFire*

+
Ensure the Parent Project section is blank, then press *Finish*.

You should now have a project in your IDE workspace called
`uberfire-tutorial` which contains a skeletal `pom.xml` file.

== Fill in the Maven POM

The first thing you'll need is a Maven `pom.xml` file that describes
all the dependencies and special build steps of your project. If you
followed the instructions for Eclipse in the previous section, you
should have this:

[source,xml]
---------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
     http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mycompany.uftutorial</groupId>
  <artifactId>uberfire-tutorial</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>war</packaging>
  <name>UberFire Tutorial Project</name>
  <description>A project Iâ€™m creating from scratch in order to learn UberFire</description>

</project>
---------

Now let's define some properties that set up fundamental project
settings, such as source encoding, built-in Maven plugin versions, and
the version numbers of the UberFire and Errai frameworks we'll be
using. Add this inside the `<project>` element, after the
`<description>` tag:

[source,xml]
---------
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.war.plugin.version>2.1.1</maven.war.plugin.version>
    <maven.clean.plugin.version>2.4.1</maven.clean.plugin.version>
    <maven.deploy.plugin.version>2.7</maven.deploy.plugin.version>
    <maven.resources.plugin.version>2.6</maven.resources.plugin.version>
    <maven.gwt.plugin.version>2.5.1</maven.gwt.plugin.version>
    <jboss-as-maven-plugin.version>7.4.Final</jboss-as-maven-plugin.version>
    <uberfire.version>0.4.0-SNAPSHOT</uberfire.version>
    <errai.version>2.4.3-SNAPSHOT</errai.version>
    <jboss.spec.version>3.0.2.Final</jboss.spec.version>
  </properties>
---------

Now, after the properties section, we'll import four Maven _BOM_
files. BOM (short for Bill Of Materials) is a Maven technique (usage
pattern) where frameworks publish a comprehensive set of dependency
versions that are known to work well with the framework. We'll import
BOMs for UberFire, Errai, and the Java EE 6 API jars.

Note that importing a BOM doesn't add any actual dependencies to your
project; it simply manages the versions of the direct and transitive
dependencies you do add in the `<dependencies>` section further down.

This section can be placed right after the properties section from the
previous snippet:

[source,xml]
---------
  <dependencyManagement>
    <dependencies>

      <dependency>
        <groupId>org.jboss.errai.bom</groupId>
        <artifactId>errai-version-master</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.errai</groupId>
        <artifactId>errai-parent</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.uberfire</groupId>
        <artifactId>uberfire</artifactId>
        <version>${uberfire.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>${jboss.spec.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
---------

So that takes care of pinning all the sensitive dependency
_versions_. Now let's declare the libraries we'll be using. Insert all
of this after the `<dependencyManagement>` section:

[source,xml]
---------
  <dependencies>
  
    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-js</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-backend-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-fs</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-jgit</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-client-api</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widgets-core-client</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widgets-commons</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-widget-markdown</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-workbench</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-javaee-all</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.spec.javax.ejb</groupId>
      <artifactId>jboss-ejb-api_3.1_spec</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <scope>provided</scope>
    </dependency>

    <!-- All of this stuff is supplied by the app server and must not be deployed with the WAR file! -->
    <dependency><groupId>org.slf4j</groupId><artifactId>slf4j-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>log4j</groupId><artifactId>log4j</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>com.google.guava</groupId><artifactId>guava-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>hsqldb</groupId><artifactId>hsqldb</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.annotation</groupId><artifactId>jsr250-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.enterprise</groupId><artifactId>cdi-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.inject</groupId><artifactId>javax.inject</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>junit</groupId><artifactId>junit</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.common</groupId><artifactId>hibernate-commons-annotations</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.javax.persistence</groupId><artifactId>hibernate-jpa-2.0-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-entitymanager</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-cdi-jetty</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-codegen-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-data-binding</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-javax-enterprise</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jaxrs-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jpa-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-navigation</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-tools</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.logging</groupId><artifactId>jboss-logging</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.resteasy</groupId><artifactId>jaxrs-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.interceptor</groupId><artifactId>jboss-interceptors-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.transaction</groupId><artifactId>jboss-transaction-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld.servlet</groupId><artifactId>weld-servlet-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-spi</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>xml-apis</groupId><artifactId>xml-apis</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai.io.netty</groupId><artifactId>netty</artifactId><scope>provided</scope></dependency>

    <!-- And finally, add this -->
    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-jboss-as-support</artifactId>
      <scope>compile</scope>
    </dependency>

  </dependencies>
---------

And that takes care of adding UberFire, Errai, and the Java EE 6 APIs
to the project. The big ugly list of provided-scope dependencies
toward the end is a necessary evil: these are the dependencies that we
inherit transitively from UberFire, Errai, and GWT which must not be
bundled in the WAR file. Maven does not provide a mechanism for
inheriting provided-scope transitive dependencies, so we have to list
them all here separately to ensure they are not bundled in the WAR.

Now on to the `<build>` section, where we define the behaviour of
several plugins we'll need in order to get the project built. The
`<build>` section can be placed after the `<dependencies>` section.

[source,xml]
---------
  <build>

    <resources>
      <resource>
        <directory>src/main/java</directory>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
      </resource>
    </resources>

    <plugins>
      <!-- see below in this guide -->
    </plugins>

  </build>
---------

The `<resources>` section adds `src/main/java` as a resource
directory, and reaffirms that `src/main/resources` is also a resource
directory. The purpose of adding `src/main/java` as a resource
directory is to ensure all the .java source files are included on the
classpath. The GWT compiler requires this. The reason we add
`src/main/resources` redundantly is because the Maven integration in
IntelliJ IDEA does not retain this default resource directory when you
add a new one. Adding both explicitly provides maximum compatibility.

Now, speaking of the GWT compiler, we need to invoke it during our
project's build. How do we teach Maven to do this and other build
steps that are unique to an UberFire-based project? That's where Maven
plugins come in.

Note that all of the following `<plugin>` elements go _inside_ the
`<plugins>` placeholder we defined in the previous step.

First up, we'll define some settings for `maven-compiler-plugin`:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>2.4</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
        </configuration>
        <dependencies>
          <dependency>
            <groupId>org.uberfire</groupId>
            <artifactId>uberfire-workbench</artifactId>
            <version>${uberfire.version}</version>
          </dependency>
        </dependencies>
      </plugin>
---------

The `source` and `target` options set the compiler for Java 1.6
compliance. This is the version of the Java language that GWT 2.5.x
supports.

The dependency on `uberfire-workbench` is the recommended way of
hinting Eclipse's Maven integration that this module contains Java
Annotation Processors that should be executed whenever an incremental
build is performed. More on this later (TODO: link to m2e setup).

Next up, the all-important `gwt-maven-plugin`.

[source,xml]
---------
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>gwt-maven-plugin</artifactId>
        <version>${maven.gwt.plugin.version}</version>
        <configuration>

          <noServer>true</noServer>

          <!-- Change to false if using client-side Bean Validation -->
          <strict>true</strict>

          <!-- If you can't use strict mode, diagnose mysterious
               rebind errors by setting this to DEBUG -->
          <logLevel>INFO</logLevel>

          <runTarget>http://localhost:8080/${project.artifactId}/</runTarget>

          <!-- do not insert line breaks in this string; it breaks Windows compatibility -->
          <extraJvmArgs>-Xmx1g -Xms756m -XX:MaxPermSize=256m -XX:CompileThreshold=1000</extraJvmArgs>

        </configuration>
        <executions>
          <execution>
          <id>gwt-compile</id>
            <goals>
              <goal>resources</goal>
              <goal>compile</goal>
            </goals>
          </execution>
          <execution>
            <id>gwt-clean</id>
            <phase>clean</phase>
            <goals>
              <goal>clean</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
---------

This is a lot to digest. Let's take it one step at a time.

First, we configure `noServer` because we'll be doing our Dev Mode
testing against a real JBoss EAP or WildFly instance. We don't want
Dev Mode to start its embedded Jetty server.

Next, we enable GWT's strict mode. This causes the build to fail with
a helpful error message when you use Java APIs that aren't available
in GWT's in-browser runtime environment (GWT calls this
_non-translatable_ code). Without strict mode, these errors will show
up later in the compile in a way that gives you no clue what happened.

NOTE: There is a caveat to using strict mode: it is not compatible
with client-side Bean Validation, so you will have to turn it off when
and if you start using Bean Validation in your app's client-side
code. The inferior alternatve to strict mode is to set Dev Mode's
`logLevel` to `DEBUG` and sift through the output for clues about
non-translatable code. But we don't have to worry about that at this
point.

Moving on, we set `runTarget` to the local URL where your webapp will
be served by the JBoss EAP or WildFly server on your workstation.

The `extraJvmArgs` setting increases the memory limits for the Dev
Mode JVM, and asks its JIT compiler to be more aggressive in
generating native code. We've done some experimenting and found a
compile threshold of 1000 allows Dev Mode to start up a little faster.

Next up, we configure `maven-war-plugin`, which produces the WAR file
during the build's _package_ phase:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <version>${maven.war.plugin.version}</version>
        <configuration>
          <warName>${project.artifactId}</warName>
          <outputFileNameMapping>@{artifactId}@-@{baseVersion}@@{dashClassifier?}@.@{extension}@</outputFileNameMapping>

          <!--
            List of files to leave out of the WAR file:
            1. GWT client-only classes confuse Hibernate and Weld's
               classpath scanners
            2. The existence of log4j.properties interferes with JBoss
               Logging configuration
           -->
          <packagingExcludes>**/client/**/*.class,**/log4j.properties</packagingExcludes>
        </configuration>
      </plugin>
---------

The first configuration tweak changes the name of the generated WAR
file to just __projectname__.war rather than the default
__projectname__-__version__.war. We find this more convenient to work
with, because the deployment URL remains stable that way. If you
prefer to have the version number in the WAR file name, feel free to
omit the `<warName>` setting.

The `<outputFileNameMapping>` tells the WAR plugin exactly what names
to give JAR files it copies into `target/WEB-INF/lib/`. This is
necessary because Eclipse and Maven sometimes use slightly different
names, and you end up with duplicate libraries on your classpath. This
duplication can cause ``Ambiguous bean reference'' errors from Weld
when your server-side app is starting up.

The `<packagingExcludes>` setting is vital, though: this keeps the
client-side-only classes off the web server. Anything that scans your
webapp for annotated classes or classes of a certain type (such as
Hibernate and Weld) tends to trip over classes that refer to GWT types
that only make sense in the client environment, such as Widgets and
JavaScript Native Methods. We'll get to these topics later, but for
now, just be sure to exclude your client-only classes from the .war
file. We also omit the `log4j.properties` file from the WAR file
so it doesn't take over JBoss Logging configuration.

The `<packagingExcludes>` setting accepts a comma-separated list of
patterns, so if you need to exclude more stuff later on, you can.

Now on to the clean configuration:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-clean-plugin</artifactId>
        <version>${maven.clean.plugin.version}</version>
        <configuration>
          <filesets>
            <fileset>
              <directory>${basedir}</directory>
              <includes>
                <include>www-test/**</include>
                <include>.gwt/**</include>
                <include>.errai/**</include>
                <include>src/main/webapp/WEB-INF/deploy/**</include>
                <include>src/main/webapp/WEB-INF/lib/**</include>

                <!-- If you rename your GWT module, you MUST update this too -->
                <include>src/main/webapp/UberFireTutorial/**</include>

                <include>**/gwt-unitCache/**</include>
                <include>**/*.JUnit/**</include>
                <include>monitordb.*</include>
              </includes>
            </fileset>
          </filesets>
        </configuration>
      </plugin>
---------

So yeah, the GWT tools (compiler, Dev Mode, and the JUnit test
harness) generate a lot of junk in a lot of places. Errai also
generates junk, but it's a bit more polite and keeps it all under one
.errai directory.

The one thing to keep in mind here is the commented line: if you
rename your GWT module (which we'll talk about in the next section)
you will also have to update this line to match. If the `mvn clean`
command fails to remove your generated GWT module directory, you will
run into the dreaded ``Module _YourModule_ may need to be
(re)compiled'' error.

And now on to the resources plugin:

[source,xml]
---------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-resources-plugin</artifactId>
        <version>${maven.resources.plugin.version}</version>
        <executions>
          <execution>
            <id>css-resources</id>
            <phase>process-resources</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <inherited>false</inherited>
            <configuration>
              <resources>
                <resource>
                  <directory>src/main/java/com/mycompany/uftutorial/client/css</directory>
                  <filtering>false</filtering>
                </resource>
              </resources>
              <outputDirectory>src/main/webapp/css</outputDirectory>
            </configuration>
          </execution>
          <execution>
            <id>copy-resources</id>
            <phase>prepare-package</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <configuration>
              <resources>
                <resource>
                  <directory>target/generated-sources/annotations</directory>
                </resource>
              </resources>
              <outputDirectory>${basedir}/target/classes</outputDirectory>
            </configuration>
          </execution>
        </executions>
      </plugin>
---------

This configuration serves two purposes: firstly, it copies CSS files
used by your Errai UI templates to a place where they will be
accessible from the web when your WAR file is deployed. Secondly, it
copies .java source files that were generated by UberFire's annotation
processors into a place where they'll be on the classpath when the GWT
compiler runs. Yes, the GWT compiler needs the .java source file for
every class you want it to compile to JavaScript.

Last but not least, the `jboss-as-maven-plugin`:

[source,xml]
---------
      <plugin>
        <groupId>org.jboss.as.plugins</groupId>
        <artifactId>jboss-as-maven-plugin</artifactId>
        <version>${jboss-as-maven-plugin.version}</version>
        <configuration>
          <filename>${project.artifactId}.${project.packaging}</filename>
        </configuration>
      </plugin>
---------

The `jboss-as-maven-plugin` is a handy tool that lets you deploy and
undeploy your project from JBoss AS 7, EAP 6, or WildFly 8. As long as
one of those servers is running locally, you can deploy your app to it
with the command `mvn jboss-as:deploy`.

Phew! That's it for the `<plugins>` section.

Just one more section to go, and you can skip it if nobody will even
use Eclipse to develop your project.

The `<pluginManagement>` section goes inside the `<build>` section
(it's a sibling of <plugins>, not a child).

[source,xml]
---------
    <pluginManagement>
      <plugins>
        <!--This plugin's configuration is used to store Eclipse m2e settings 
          only. It has no influence on the Maven build itself. -->
        <plugin>
          <groupId>org.eclipse.m2e</groupId>
          <artifactId>lifecycle-mapping</artifactId>
          <version>1.0.0</version>
          <configuration>
            <lifecycleMappingMetadata>
              <pluginExecutions>
                <pluginExecution>
                  <pluginExecutionFilter>
                    <groupId>org.codehaus.mojo</groupId>
                    <artifactId>gwt-maven-plugin</artifactId>
                    <versionRange>[2.4.0,)</versionRange>
                    <goals>
                      <goal>resources</goal>
                    </goals>
                  </pluginExecutionFilter>
                  <action>
                    <ignore></ignore>
                  </action>
                </pluginExecution>
              </pluginExecutions>
            </lifecycleMappingMetadata>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
---------

As the comment says, this is actually some Eclipse-specific
configuration that's stored in the POM. It doesn't have any effect on
the build if you're not in Eclipse.

If you plan on developing against Errai or UberFire snapshot releases
(these are published continuously during the development cycle, and
are the easiest way to get access to the latest features and fixes
available), add this section after the end of the `<build>` section:

[source,xml]
---------
  <repositories>
    <repository>
      <id>jboss-public-repository-group</id>
      <name>JBoss Public Repository Group</name>
      <url>http://repository.jboss.org/nexus/content/groups/public/</url>
      <layout>default</layout>
      <releases>
        <enabled>true</enabled>
        <updatePolicy>never</updatePolicy>
      </releases>
      <snapshots>
        <enabled>true</enabled>
        <updatePolicy>daily</updatePolicy>
      </snapshots>
    </repository>
  </repositories>
---------

== Set up a .gitignore (or similar for your VCS)

It's important to avoid tracking generated files in source
control. When you accidentally check in a generated file, it will lead
to bad things in the future: merge conflicts, confusion, and coworkers
hitting you on the head with rubber chickens.

Here's the set of files you want your version control system to
ignore. This can be used as-is in a `.gitignore` file, but it should
be easy to adapt to the VCS you're using:

---------
.classpath
.project/
.settings/
.factorypath
target/
.errai/
src/main/webapp/UberFireTutorial/
src/main/webapp/WEB-INF/classes/
src/main/webapp/WEB-INF/deploy/
src/main/gwt-unitCache/
war/
gwt-unitCache/
.apt_generated/
---------

== Set up the web.xml

The `web.xml` file is the main and most fundamental configuration file
for your web application. In Java EE talk, it's your ``deployment
descriptor.''

Here's what you need in a typical UberFire `web.xml`. Create a file
`src/main/webapp/WEB-INF/web.xml` and fill it with the following:

[source,xml]
---------
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0">

  <filter>
    <filter-name>UberFire Security Filter</filter-name>
    <filter-class>
      org.uberfire.security.server.UberFireSecurityFilter
    </filter-class>
    <init-param>
      <param-name>org.uberfire.cookie.id</param-name>
      <param-value>errai-cdi-workbench-cookie</param-value>
    </init-param>
  </filter>

  <filter-mapping>
    <filter-name>UberFire Security Filter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

  <servlet>
    <servlet-name>UberFireServlet</servlet-name>
    <servlet-class>org.uberfire.server.UberfireServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>UberFireServlet</servlet-name>
    <url-pattern>/UberFireTutorial/UberFire.html</url-pattern>
  </servlet-mapping>

  <servlet>
    <servlet-name>ErraiServlet</servlet-name>
    <servlet-class>org.jboss.errai.bus.server.servlet.DefaultBlockingServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>ErraiServlet</servlet-name>
    <url-pattern>*.erraiBus</url-pattern>
  </servlet-mapping>

</web-app>
---------

The following subsections examine the contents of `web.xml` in detail.

=== UberFire security filter

The `UberFireSecurityFilter` is mapped to `/*` and so it is consulted
for every request to a servlet or static resource in your web
application. In other words, this filter makes an allow/deny decision
for every HTTP request to your application.

How do you control the behaviour of this filter? It depends.  The
filter relies on a series of pluggable mechanisms to make its
decisions about how users can identify themselves, which
username+password combinations are valid, and which URLs anonymous and
authenticated users are allowed to access.

For this demo, we will control access using the default settings, which are:

* Authentication Manager (controls login and logout): `HttpAuthenticationManager`
** Authentication Schemes (extract provided credentials from HTTP requests):
*** HTTP BASIC (`HttpBasicAuthenticationScheme`)
*** JAAS standard form authentication, i.e. POST to j_security_check (`FormAuthenticationScheme`)
*** UberFire ``Remember Me'' cookies (`RememberMeCookieAuthScheme`)
** Authentication Providers: `DefaultAuthenticationProvider` and `RememberMeCookieAuthProvider`
** Authenticated Storage Providers: `HttpSessionStorage` and `CookieStorage`
** Resource Manager: `URLResourceManager`
** Role Providers: `PropertyUserSource` (read from the `users.properties` file)
** Subject Properties Provider: Not used
* Authorization Manager: `DefaultAuthorizationManager`
** Voting Strategy: `ConsensusBasedVoter`
** Role Decision Manager: DefaultRoleDecisionManager
** Resource Manager: `URLResourceManager`
** Resource Decision Managers: `URLAccessDecisionManager`

TODO: define the terms used above: authentication, HTTP BASIC, JAAS,
Authenticated Storage, Resource, Role, Subject, Subject Properties,
Authorization, Decision Manager, Voting Strategy, and Consensus-based voting.

=== UberFire servlet

The UberFireServlet is responsible for serving the application's _GWT
host page_, and it's mapped to the URL
`/UberFireTutorial/UberFire.html`. Users are directed to this location
after a successful login.

The servlet works by processing the FreeMarker template
`app.html.template` and serving the result to the client.

TIP: What's a GWT Host Page? That's a web page that links to the
JavaScript payload that was produced by the GWT compiler at compile
time. We'll name the GWT module in this app `UberFireTutorial`, so
our `app.html.template` includes a `<script>` tag pointing to
`UberFireTutorial/UberFireTutorial.nocache.js`, the file produced by
the GWT compiler that ties all its output together.

=== Errai servlet

The ErraiServlet manages the communication bus that allows
two-way-push communication between the client and the server.

== Set up UberFire security

=== Choose how users and roles are defined

UberFire security is highly pluggable, and assumes very little by
default. Before we set up a list of users, we need to tell the
framework how we intend to access user information. Any class that
implements UberFire's
`org.uberfire.security.auth.AuthenticationSource` interface can tell
the framework which credentials are valid and which are not.

UberFire comes with a starter set of AuthenticationSource
implementations. For production use, you will likely implement your
own AuthenticationSource that ties your UberFire application into your
corporate LDAP or Kerberos system. But for this tutorial, we'll use
`org.uberfire.security.server.auth.source.PropertyUserSource`, a
simple AuthenticationSource that reads usernames and passwords from a
Java Properties file.

UberFire uses Java's standard ServiceLoader facility to determine
which AuthenticationSource implementations it should use.  To select a
particular class as the authentication source for your application,
you put its fully-qualified class name in the file
`src/main/resources/META-INF/services/org.uberfire.security.auth.AuthenticationSource`.

Create that file now, and paste this into it:

---------
org.uberfire.security.server.auth.source.PropertyUserSource
---------

UberFire Security can use more than one AuthenticationSource at a
time. If you want more than one, list each fully-qualified class name
on its own line in the file. You can also put comments in the file;
ServiceLoader ignores everything after a `#` character on any line,
and also ignores leading and trailing whitespace and empty lines.

What about roles? Configuring role providers works differently, but in
practice, most AuthenticationSource implementations (including
PropertyUserSource) are also RoleProvider implementations. So we're
already set for users and roles. Let's move on.

TODO: the mechanism for configuring RoleProviders should not be different.

=== Define users and roles

Our application uses the `PropertyUserSource` for its list of users,
passwords, and role memberships. This user source is mostly applicable
to development and demo environments. It gets its user, password, and
role membership information from the file
`src/main/resources/users.properties`.

You can define a default set of users by filling in
`src/main/resources/users.properties` with something like this:

---------
admin=admin,ADMIN,USERS,DIRECTOR,MANAGER
director=director,USERS,DIRECTOR,MANAGER
user=user,USERS
guest=guest
---------

The format of each line is `username=password[,ROLE1[,ROLE2[,...]]]`,
where the parts in brackets are optional.

=== Create a login.jsp

We've chosen a mechanism for representing users, passwords, and
roles. But how do we initiate a login request?

UberFire supports a variety of authentication mechanisms, including
JAAS form authentication. This mechanism is part of the Java Servlets
specification: a POST request to the URL `j_security_check` with form
parameters `j_username` and `j_password` constitutes a login
request. We'll create a `login.jsp` page with a form which submits
the correct information to this special URL.

Place the following file in `src/main/webapp/login.jsp`:

[source,html]
---------
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>UberFire Tutorial</title>

  <style type="text/css">
    * {
      font-family: Helvetica, Arial, sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      color: #fff;
      background:
      url('UberFireTutorial/images/bg-login.png')
      repeat #1b1b1b;
      font-size: 14px;
      text-shadow: #050505 0 -1px 0;
      font-weight: bold;
    }

    li {
      list-style: none;
    }

    #dummy {
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: solid 3px #777973;
      height: 250px;
      width: 100%;
      background:
      url('UberFireTutorial/images/bg-login-top.png')
      repeat #fff;
      z-index: 1;
    }

    #dummy2 {
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: solid 2px #545551;
      height: 252px;
      width: 100%;
      background: transparent;
      z-index: 2;
    }

    #login-wrapper {
      margin: 0 0 0 -160px;
      width: 320px;
      text-align: center;
      z-index: 99;
      position: absolute;
      top: 0;
      left: 50%;
    }

    #login-top {
      height: 120px;
      width: 401px;
      padding-top: 20px;
      text-align: center;
    }

    #login-content {
      margin-top: 120px;
    }

    label {
      width: 70px;
      float: left;
      padding: 8px;
      line-height: 14px;
      margin-top: -4px;
    }

    input.text-input {
      width: 200px;
      float: right;
      -moz-border-radius: 4px;
      -webkit-border-radius: 4px;
      border-radius: 4px;
      background: #fff;
      border: solid 1px transparent;
      color: #555;
      padding: 8px;
      font-size: 13px;
    }

    input.button {
      float: right;
      padding: 6px 10px;
      color: #fff;
      font-size: 14px;
      background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#a4d04a), to(#459300));
      text-shadow: #050505 0 -1px 0;
      background-color: #459300;
      -moz-border-radius: 4px;
      -webkit-border-radius: 4px;
      border-radius: 4px;
      border: solid 1px transparent;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
    }

    input.button:hover {
      background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#a4d04a), to(#a4d04a), color-stop(80%, #76b226));
      text-shadow: #050505 0 -1px 2px;
      background-color: #a4d04a;
      color: #fff;
    }

    div.error {
      padding: 8px;
      background: rgba(52, 4, 0, 0.4);
      -moz-border-radius: 8px;
      -webkit-border-radius: 8px;
      border-radius: 8px;
      border: solid 1px transparent;
      margin: 6px 0;
    }
  </style>
</head>

<body id="login">

<div id="login-wrapper" class="png_bg">
  <div id="login-top">
    <img src="UberFireTutorial/images/uf_logo.png" alt="UberFire Logo" title="Powered By UberFire"/>
  </div>

  <div id="login-content">
    <form action="j_security_check" method="post">
      <p>
        <label>Username</label>
        <input value="" name="j_username" class="text-input" type="text"/>
        <br style="clear: both;"/>
      </p>

      <p>
        <label>Password</label>
        <input name="j_password" class="text-input" type="password"/>
        <br style="clear: both;"/>
      </p>

      <p>
        <input class="button" type="submit" value="Sign In"/>
      </p>
    </form>
  </div>
</div>
<div id="dummy"></div>
<div id="dummy2"></div>
</body>
</html>
---------

The important part of this file is the form that posts `j_username`
and `j_password` to the `j_security_check` URL. This will be
recognized by UberFireSecurityFilter as a login attempt.

TODO: `/login.jsp` should not be a hardcoded path. Could rely mostly on
the welcome-page setting in web.xml.

=== Create a url_filter.yaml

If we refused to serve _anything_ to an unauthenticated user, nobody
would be able to get to the beautiful login page we just created!
Fortunately there's a way to ``punch a hole'' in the security filter
so the login page and its linked assets (CSS, images) can be served.

Create the file `src/main/resources/url_filter.yaml` and put this in
it:

[source,yaml]
---------
filter:
   - pattern: /admin/**
     access: ADMIN
   - pattern: /config/**
     access: ADMIN, USER
   - pattern: /private/**

exclude:
   - /*.ico
   - /UberFireTutorial/images/**
   - /UberFireTutorial/css/**
   - /css/**
   - /plugins/**
---------

This example file shows you how to restrict certain URL paths to
certain roles, and also how to exclude some paths from the
authentication and authorization checks altogether.

TODO: why doesn't login.jsp have to be in this list?

At this point, we have fully configured UberFire Security.

== Set up the VFS

Before we turn to the client side of our application, there's one more
server-side piece that needs to be configured: the Virtual File System
(VFS) provider.

UberFire's Workbench GUI module relies on the UberFire VFS for storing
perspective definitions, perspective geometries, editor-to-filename
associations, and more.

You select the UberFire's VFS implementations the same way as you
choose UberFire security components: using Java's Service Loader
mechanism. So create the file
`src/main/resources/META-INF/services/org.uberfire.java.nio.file.spi.FileSystemProvider`
and put the following line into it:

---------
org.uberfire.java.nio.fs.jgit.JGitFileSystemProvider
org.uberfire.java.nio.fs.file.SimpleFileSystemProvider
---------

This tells UberFire to use its git-based filesystem as the default VFS
(because it is first in the list), and also registers the simple
filesystem provider. The simple filesystem provider is not optional;
it is required for temporary files.

== Enable the UberFire CDI Extensions

UberFire relies on two CDI Extensions to get its job done. CDI
Extensions are enabled by Java's Service Loader, which should be
pretty familiar by now.

Create the file
`src/main/resources/META-INF/services/javax.enterprise.inject.spi.Extension`
and paste the following contents into it:

---------
org.uberfire.commons.services.cdi.StartupBeanExtension
org.uberfire.security.server.cdi.SecurityExtension
---------

The StartupBeanExtension enables UberFire's `@Startup` annotation, and
the SecurityExtension is a workaround that explicitly marks a type
within the UberFire framework as "not a CDI bean."

TODO: why doesn't UF enable these extensions in its own
META-INF/services files?

== Create the GWT host page template

As mentioned earlier, GWT apps need a _host page_ that points the
browser at their main __ModuleName__.nocache.js file. In an UberFire
application, UberFireServlet takes this responsibility, and it does so
by processing a FreeMarker template called `app.html.template`.

Create the file `src/main/resources/app.html.template` and fill it
with this:

[source,html]
---------
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>UberFire Showcase</title>
  <link rel="stylesheet" href="css/uberfire-loading.css">
  <link rel="stylesheet" href="css/uberfire-showcase.css">
  <link rel="stylesheet" href="css/ruleflow.css">
</head>
<body>

  <script type="text/javascript">
    var current_user = { name:"@{name}", roles:[@{roles}] }
  </script>

  <!-- loading indicator to display while the app is being loaded -->
  <div id="loading">
    <div class="loading-indicator">
      <img src="images/loading-icon.gif" width="32" height="32"
           style="margin-right: 8px; float: left; vertical-align: top;">
        Please wait<br/>
        <span id="loading-msg">Loading application...</span>
    </div>
  </div>

  <!-- The GWT js file generated at compile time -->
  <script type="text/javascript" src='UberFireTutorial.nocache.js'></script>
</body>
</html>
---------

== Create a client-side entry point class

Okay, enough mucking around with directory structure and configuration
files! We went through all of that because it's important to
understand everything you put into your web application, and doing
something is the best way to learn it. In the future, you'll probably
want to just start with a copy of a working demo app and delete the
parts you don't need.

An _entry point_ is a place where a program starts its execution. In
JavaSE programs, the entry point is the famous `public static void
main(String[] args)` method. In a Java EE environment, you typically
have many entry points: every Servlet and JAX-RS resource method is an
entry point into the application.

In an UberFire application, there are typically _client side_
components (the parts that are translated to JavaScript and execute in
the browser) and _server side_ components (the parts that are compiled
to class files and deplotyed in the war file.)

Any class in a client-only package of your application can be a
client-side entry point into your application. To designate a class as
an entry point, annotate it with `@EntryPoint`. Put the following in
`src/main/java/com/mycompany/uftutorial/client/ClientEntryPoint.java`:

[source,java]
---------
@EntryPoint
public class ClientEntryPoint {
  private void start(@Observes final ApplicationReadyEvent event) {
  }
}
---------

The `@EntryPoint` annotation tells the framework that the class is a
CDI Bean that should be instantiated when the page is loaded into the
browser. You can name an entry point class anything you like. You can
create as many `@EntryPoint` classes as you want, but you can't
specify what order they will be instantiated in. It's unusual to have
more than one.

The `start()` method is a CDI observer method. The UberFire Workbench
framework fires an `ApplicationReadyEvent` when the framework has
finished initializing.

NOTE: Since the entry point class is a CDI bean, it's tempting to use
the CDI `@PostConstruct` annotation on the method that runs your
initialization code. However, this does not work in practice because
it's usually invoked too early: before many parts of the framework
(including the Errai communication bus) have had a chance to
initialize. Stick with observing `ApplicationReadyEvent` and you'll be
fine.

Right now, our entry point method is empty! What kind of stuff would
you normally put in there for bootstrapping an UberFire app? Let's
first create a panel and then come back to that question.

== Create a Workbench Screen

UberFire interfaces are made up of a few fundamental building blocks:
Widgets, Layout Panels, Screens, Workbench Panels, Menu Bars, Tool
Bars, and Perspectives. Layout Panels can contain Widgets and other
Layout Panels, and Perspectives contain Workbench Panels, an optional
Menu Bar, and an optional Tool Bar. Perspectives split up the screen
into multiple resizeable regions, and end users can drag and drop
Panels between these regions to customize their workspace.

To create your first screen, create the file
`src/main/java/com/mycompany/uftutorial/client/HelloWorldScreen.java`:

[source,java]
---------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.Dependent;

import org.uberfire.client.annotations.WorkbenchPartTitle;
import org.uberfire.client.annotations.WorkbenchPartView;
import org.uberfire.client.annotations.WorkbenchScreen;

import com.google.gwt.user.client.ui.IsWidget;
import com.google.gwt.user.client.ui.Label;

@Dependent
@WorkbenchScreen(identifier = "com.mycompany.uftutorial.client.HelloWorldScreen")
public class HelloWorldScreen {

  private Label label = new Label("Hello UberFire!");

  @WorkbenchPartTitle
  public String getTitle() {
    return "Greetings";
  }

  @WorkbenchPartView
  public IsWidget getView() {
    return label;
  }
}
---------

The class itself is quite simple: one private field and two public
methods. But we're seeing a bunch of annotations for the first
time. Let's examine them one by one.

@Dependent::

 Marks this class as a _dependent scoped CDI bean_ that should be
 freshly instantiated every time a new instance is called
 for. Contrast with `@ApplicationScoped`, which marks a CDI bean that
 should be created only one time over the life of the application.

@WorkbenchScreen::

 Declares that the class defines a Screen in the application.

@WorkbenchPartTitle::

 Denotes the method that returns the Screen's title. Every Screen must
 have a `@WorkbenchPartTitle` method.

@WorkbenchPartView::

 Denotes the method that returns the Panel's view. The view can be any
 class that extends GWT's `Widget` class or implements GWT's
 `IsWidget` interface. In this example, we're returning a GWT `Label`,
 which is a GWT API for a `<div>` element with text in it. Every Screen
 must have a `@WorkbenchPartView` method.

.About Client-Side Scopes
NOTE: CDI scopes in the client side are tied to the lifecycle of the
web page in the browser, not the lifecycle of the server-side web
application. In the client, the Application Scope begins when the page
is first loaded, and ends when when the user navigates away from the
page--either by visiting a different URL, or by closing the browser
window/tab. Currently, the Session and Conversation scopes are not
defined on the client side.

== Define a perspective

Now we have a Screen, but nowhere to put it. Remember, the UberFire
workbench UI is arranged as Workbench -> Perspective -> Workbench
Panel -> Screen. Perspectives dictate the position and size of
Workbench Panels. We need to define a Perspective.

Copy the following source code into the file
`src/main/java/com/mycompany/uftutorial/client/HomePerspective.java`:

[source,java]
---------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.ApplicationScoped;

import org.uberfire.client.annotations.Perspective;
import org.uberfire.client.annotations.WorkbenchPerspective;
import org.uberfire.mvp.impl.DefaultPlaceRequest;
import org.uberfire.workbench.model.PanelType;
import org.uberfire.workbench.model.PerspectiveDefinition;
import org.uberfire.workbench.model.impl.PartDefinitionImpl;
import org.uberfire.workbench.model.impl.PerspectiveDefinitionImpl;

@ApplicationScoped
@WorkbenchPerspective(
    identifier = "com.mycompany.uftutorial.client.HomePerspective",
    isDefault = true)
public class HomePerspective {

  @Perspective
  public PerspectiveDefinition getPerspective() {
    final PerspectiveDefinition p = new
  PerspectiveDefinitionImpl(PanelType.ROOT_STATIC);
    p.setName(getClass().getName());
    p.getRoot().addPart(
            new PartDefinitionImpl(
                    new DefaultPlaceRequest(HelloWorldScreen.class.getName())));
    p.setTransient(true);
    return p;
  }

}
---------

== Define a GWT module

So we created some client-side Java code and some server-side Java
code, but how will the GWT compiler know the difference? How can it
tell what's supposed to be packaged up for running on the browser, and
what it should ignore?  That's where GWT modules come in.

Create a file at
`src/main/java/com/mycompany/uftutorial/UberFireTutorial.gwt.xml` and
fill it with the following:

[source,xml]
---------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.5//EN"
        "http://google-web-toolkit.googlecode.com/svn/releases/2.5/distro-source/core/src/gwt-module.dtd">

<!-- If you rename the module, update the maven-clean-plugin
     configuration in pom.xml and the .gitignore file. -->
<module rename-to="UberFireTutorial">

  <inherits name="org.jboss.errai.enterprise.All"/>

  <inherits name="org.uberfire.UberfireJS"/>

  <inherits name="org.uberfire.security.UberfireSecurityClient"/>

  <inherits name="org.uberfire.UberfireWorkbench"/>
  <inherits name="org.uberfire.UberfireWidgetsCore"/>
  <inherits name="org.uberfire.UberfireBackend"/>

  <source path="client"/>
  <source path="shared"/>
</module>
---------

What is all this? Let's step through it.

The root element of a GWT module descriptor is `<module>`. The default
name of a module is a fully-qualified name that includes the Java
package it sits in. For example, this module's default name is
`com.mycompany.uftutorial.UberFireTutorial`. When we're creating a GWT
module for a deployable application, it's usually more convenient to
give it a simple, unqualified name. So we use the optional `rename-to`
attribute to give our module a simple, unqualified name.

Next, we see a series of `<inherits>` elements. These tell GWT which
other GWT modules our app depends on. Just like Maven dependencies,
modules can depend on other modules, and when you inherit one you
_transitively inherit_ all the modules it depends on.

Finally, there are two `<source>` paths defined. This is how you tell
GWT which packages it should translate to JavaScript. In our case, we
want GWT to translate everything under the
`com.mycompany.uftutorial.client` and
`com.mycompany.uftutorial.shared` packages.

.GWT does not manage the classpath!
TIP: When you inherit a GWT module, you're only telling the GWT
compiler that you intend to use code from that module--you're not
telling it where to find that module. You are responsible for ensuring
the module is on the classpath when the GWT compiler runs. So when you
inherit a GWT module, make sure it's also a dependency in your
pom.xml.

== Time to see it work!

We've come a long way since we started with that empty
directory. Let's reward all the hard work by starting our app and
seeing it do something!



== Factor out the panel's contents

== Create a second panel

== Link the two panels

== Add a menu bar

== Add a toolbar

== Define a second perspective
