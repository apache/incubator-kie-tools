= UberFire 0.5 Developer Guide
UberFire Community <uberfire@googlegroups.com>
:toc:
:source-highlighter: highlightjs
:stylesheet: asciidoctor.css
:link-suffix: .asciidoc
:icons:
:imagesdir: ./images

This document explains the major features of UberFire 0.5. It is
organized by UberFire feature. It includes detailed explanations and
usage examples that show how to use each part of UberFire
correctly. If you want a brief high-level overview, see
link:tutorial{link-suffix}[the UberFire Overview] instead.

This guide assumes you are already familiar with the basics of GWT,
CDI, and Errai. If you are not yet familiar with these things, or you
need to brush up on any of them, start with our hands-on introduction,
link:tutorial{link-suffix}[the UberFire Tutorial].


== UberFire Workbench

You can program UberFire applications, application support libraries,
and UberFire extensions using the Java API, the JavaScript API, or a
combination of both. Currently, the Java API exposes more
functionality than the JavaScript API, but the long term plan is to
expose all available functionality through both APIs.

.Help Wanted!
NOTE: If there's something you would like to be able to do from the
JavaScript API and that feature is not exposed yet, submit a pull
request to the UberFire project on GitHub!

=== Overall Organization

The UberFire workbench module is composed of layers that work
together. The following diagram shows how the parts are layered. Components
interact with those directly above and below them, as well as those
they are connected to with an arrow (&#x21e3;).

[cols="8*^"]
|===
 8+| PlaceManager
 2+| PerspectiveManager 2+| &#x21e3;      3+| ActivityManager       .3+| &#x21e3;
 4+| PanelManager                         2+| AuthorizationManager  .2+| &#x21e3;
 3+| PanelPresenters   .2+| &#x21e3;      2+| ResourceManager
 3+| PanelViews                         4.3+| Activities (Your Application's Behaviour)
.2+| &#x21e3;         3+| PartPresenters
                      3+| PartViews
 8+| GWT Widgets
 8+| HTML DOM
|===

There are a lot of parts to this diagram, but for the most part, your
application will supply Activity classes that describe the UI and
business logic of your components, and call into the PlaceManager to
change which acitivies are visible on the screen. The rest of the
components will do the right thing without help from you.

So familiarize yourself with the names of the components, but don't
feel you have to understand the whole thing at this point!  We've put
the diagram first so you can refer back to it to get your bearings as
new parts of the system are introduced.

=== Constructing the UI

This section covers the capabilities of UberFire's Java-based
Workbench API.


==== Workbench Activities and PlaceRequests

In UberFire, your `WorkbenchScreenActivity` and
`WorkbenchEditorActivity` implementations provide the bulk of the user
interface and application-specific behaviour that your users will
spend most of their time interacting with. Collectively, screens and
editors are referred to as "Workbench Parts." The only difference
between a Screens and an Editor is that Editors track clean/dirty
state, and can prompt the user about unsaved changes before closing.

You can define a workbench part in three ways: by creating a Java
class annotated with `@WorkbenchScreen` or `@WorkbenchEditor`; by
creating a subclass of `AbstractWorkbenchScreenActivity` or
`AbstractWorkbenchEditorActivity`; or through the JavaScript runtime
extension API by providing a JSON description of the activity.

.Example Screen Declared Using Annotations
[code, java]
----
@Dependent // <1>
@WorkbenchScreen(identifier = "HelloScreen") // <2>
public class HelloScreen { // <3>

  private final Label label = new Label();

  @WorkbenchPartTitle
  public String getTitle() {
    return "Greetings";
  }

  @WorkbenchPartView
  public IsWidget getView() {
    return label;
  }

  @OnStartup
  public void start(PlaceRequest place) {
    label.setText("Hello " + place.getParameter("name", "World")); // <4>
  }
  
}
----
<1> All Workbench Screens and Editors are Dependent-scoped CDI beans.
<2> Tells UberFire that this bean implements the behaviour of a screen
  that's referred to as "HelloScreen". The identifier can be any
  string, but since it will appear in the browser's location bar,
  spaces and URL-meaningful punctuation are discouraged.
<3> UberFire Screens and Editors that are declared with the
  `@WorkbenchScreen` or `@WorkbenchEditor` annotation need not implement
  any particular interface, but there are still some interface-like
  requirements enforced by the annotation processor (see the
  `@WorkbenchScreen` JavaDoc for full details)
<4> PlaceRequests can include named parameters. In this case, we retrieve
  the name of the person to greet from a parameter, defaulting to
  "World" if the parameter is not present. See the section on PlaceRequests for details.

In the above example, we have declared a new Workbench Screen using
UberFire's annotation-based API. Behind the scenes, UberFire will use
a Java annotation processor to generate the source code for an
implementation of WorkbenchScreenActivity. This approach lets your
screen class "inherit" default behaviour without needing to extend a
particular base class (for example, AbstractWorkbenchScreenActivity).
This leaves you free to have your screens extend some
application-specific superclass.

On the other hand, you can choose to implement WorkbenchScreenActivity
directly, or by subclassing AbstractWorkbenchScreenActivity. When you
do this, the Java type system works in your favour and your IDE can
give you more help with the nuts and bolts of implementing a screen.

.Example Screen Declared By Extending AbstractWorkbenchScreenActivity
[code,java]
----
@Dependent // <1>
@Named("HelloWorldScreenExtends") // <2>
public class HelloWorldScreenExtends extends AbstractWorkbenchScreenActivity { // <3>

  @Inject
  public HelloWorldScreenExtends(PlaceManager placeManager) { // <4>
    super(placeManager);
  }

  private final Label label = new Label();

  @Override
  public String getTitle() { // <5>
    return "Greetings";
  }

  @Override
  public IsWidget getWidget() { // <5>
    return label;
  }

  @Override
  public void onStartup(PlaceRequest place) { <6>
    super.onStartup(place);
    label.setText("Hello " + place.getParameter("name", "World"));
  }

  @Override
  public String getSignatureId() { // <7>
    return "HelloWorldScreenExtends";
  }

  @Override
  public Collection<String> getRoles() { // <8>
    return Collections.emptyList();
  }

  @Override
  public Collection<String> getTraits() { // <9>
    return Collections.emptyList();
  }
}
----
<1> All screen and editor activities are Dependent-scoped CDI beans
<2> The place ID of a screen activity is its CDI bean name. All screen
  and editor activity implementations must be `@Named` with a unique
  identifier.
<3> In this example, we're getting some help in the implementation of
  the `WorkbenchScreenActivity` interface by extending
  `AbstractWorkbenchScreenActivity`. You can also implement
  `WorkbenchScreenActivity` directly and implement every method
  yourself.
<4> `AbstractWorkbenchScreenActivity` has a protected constructor that
  takes a `PlaceManager`. The best way to satisfy this is to make your
  own constructor that takes a `PlaceManager` and annotate it with
  `@Inject`. Of course, you can add extra parameters to the
  constructor if you want additional CDI dependencies
  constructor-injected.
<5> Instead of using the `@WorkbenchPartTitle` and
  `@WorkbenchPartView` annotations as in the previous example, we
  override the corresponding methods directly.
<6> Similarly, the lifecycle callbacks are overrides now. *Note that
  you have to call up to the super method for all four lifecycle calls
  (`onStartup`, `onOpen`, `onClose`, and `onShutdown`).*
<7> The Signature ID is used when registering your screen with the
  `RuntimeResourceManager`, which is part of UberFire's role-based
  access control system (see the security section of this guide for
  details). The Signature ID should typically be the same thing you
  put in the `@Named` anntation.
<8> Here, you can return the set of roles that a user must belong to
  in order to access this screen. An empty collection means anyone can
  access the screen.
<9> Traits affect the way role-based access is decided. See the
  security section for details.


==== Creating the Screen or Editor UI

In this section, we show three options for creating the user interface
of a workbench screen activity. Each of the three approaches below can
be used with `@WorkbenchScreen`-annotated classes, or with classes
that implement WorkbenchScreenActivity directly. You can mix and match
these approaches, using the approach that best suits the problem and
your style.

Each example will arrive at the same end result: a workbench screen
with a form for responding to an invitation. The screen will prompt 

===== Declarative UI With Errai UI Templates

Errai UI is the recommended approach for building user interface
components in UberFire. This brief introduction-by-example illustrates
show how well Errai UI fits with UberFire screens, but it is not a
full reference. For all the details, see
link:http://docs.jboss.org/errai/3.0.3.Final/errai/reference/html_single/#sid-51806600_ErraiUI-UseErraiUICompositecomponents[The
Errai UI section of the Errai Reference Guide].

.RSVP Template
[code, html]
----
<div>
  <label for="inviteeName">Name: </label>
  <input id="inviteeName"><br>
  
  <label for="numberOfGuests">Number of Guests:</label>
  <select id="numberOfGuests" size="1"></select><br>
  
  <label for="comments">Comments:</label>
  <textarea id="comments" rows="4" cols="40"></textarea><br> 
</div>
----

.RSVP Form With Errai UI
[code, java]
----
@Dependent
@Templated // <1>
@WorkbenchScreen(identifier = "InvitationRsvpErraiUI")
public class InvitationRsvpErraiUI extends Composite { // <2>

  @Inject
  private Caller<InvitationService> invitationService;

  @Inject @AutoBound // <3>
  private DataBinder<Rsvp> rsvpBinder;

  @Inject @Bound @DataField // <3> <4>
  private TextBox inviteeName;

  @Bound @DataField // <5>
  private final ValueListBox<Integer> numberOfGuests = new ValueListBox<Integer>(IntegerRenderer.instance());

  @Inject @Bound @DataField
  private TextArea comments;

  private boolean hasChanges;

  @OnStartup // <6>
  void setup(PlaceRequest place) {
    numberOfGuests.setAcceptableValues(Arrays.asList(1, 2, 3, 4));
    final int id = Integer.parseInt(place.getParameter("id", "-1"));
    invitationService.call(new RemoteCallback<Rsvp>() {
      @Override
      public void callback(Rsvp response) {
        rsvpBinder.setModel(response); // <7>
      }
    }).getInvitation(id);
  }

  @WorkbenchPartTitle
  public String getPartTitle() {
    return "RSVP";
  }


  @EventHandler
  private void onAnyChange(KeyDownEvent e) { // <8>
    hasChanges = true;
  }

  @OnMayClose
  public boolean mayClose() {
    if (hasChanges) {
      return Window.confirm("Changes to your RSVP have not been saved.\n"
                            + "Close without saving?"); // <9>
    }
    return true;
  }

  @EventHandler("save")
  private void save(ClickEvent e) { // <10>
    invitationService.call(new ResponseCallback() {
      @Override
      public void callback(Response response) {
        hasChanges = false;
      }
    }).saveResponse(rsvpBinder.getModel());
  }
}
----
<1> The `@Templated` annotation tells Errai UI that this CDI bean gets
  its UI layout from the corresponding template `InvitationRsvp.html`.
<2> Errai UI templated components must extend Composite. UberFire
  Parts do not have this requirement themselves (see the section on
  MVP below).
<3> The `@AutoBound` and `@Bound` annotations establish a two-way binding
  between the UI widgets and the properties of the Rsvp object. See
  the
  link:http://docs.jboss.org/errai/3.0.3.Final/errai/reference/html_single/#sid-51806600_ErraiUI-DataBinding[Errai
  Data Binding Reference] for details. Note that we can't use the
  `@Model` shortcut in this case because we need to be able to update
  the model object from within the screen class itself.
<4> The `@DataField` annotation tells Errai UI that this field
  corresponds with the HTML element in the template whose `id`,
  `class`, or `data-field` attribute is `"inviteeName"`.
<5> `numberOfGuests` is not injected because we want to call a
  non-default constructor on `ValueListBox`.
<6> We use the UberFire `@OnStartup` lifecycle method to do
  additional setup on the widgets and to fetch the `Rsvp` instance
  from the server.
<7> When we get the requested `Rsvp` instance back from the server, we
  tell Errai Data Binding to update all the model and UI state to
  match the data we received from the server.
<8> Errai UI's `@EventHandler` feature saves a lot of work here: this
  method will be called every time there is a `KeyDownEvent` on any
  widget in the screen. We use this to track the dirty state.
<9> This is an easy way to get the browser to display an
  OK/Cancel prompt, but you can't customize the buttons and it does
  not support HTML markup in the message. UberFire has its own system
  for rich and configurable modal dialogs. See the section on Popups
  for details.
<10> Finally, we react to click events on the Save button by sending
  the `Rsvp` instance back to the server and clearing the `hasChanges`
  flag when the server responds. Note that we didn't need to
  explicitly read the values out of the UI fields:
  `rsvpBinder.getModel()` always returns an up-to-date `Rsvp` instance!


===== Procedural UI With Direct Use of Widgets

We strongly recommend the use of Errai UI templates when building your
UI, but it's also possible to build the UI structure yourself
programmatically by combining widgets into panels. Here is such a
variation of the above:

.The RSVP Screen With Programmatic Assembly of UI
[code, java]
----
@Dependent
@WorkbenchScreen(identifier = "InvitationRsvpPlainWidgets")
public class InvitationRsvpPlainWidgets {

  @Inject
  private Caller<InvitationService> invitationService;

  @Inject @AutoBound // <1>
  private DataBinder<Rsvp> rsvpBinder;

  private final VerticalPanel panel = new VerticalPanel();

  @Bound
  private final TextBox inviteeName = new TextBox();

  @Bound
  private final ValueListBox<Integer> numberOfGuests = new ValueListBox<Integer>(IntegerRenderer.instance());

  @Bound
  private final TextArea comments = new TextArea();

  private final Button save = new Button("Save");

  private boolean hasChanges;

  @OnStartup
  public void setup(PlaceRequest place) {
    numberOfGuests.setAcceptableValues(Arrays.asList(1, 2, 3, 4));

    final int id = Integer.parseInt(place.getParameter("id", "-1"));
    invitationService.call(new RemoteCallback<Rsvp>() {
      @Override
      public void callback(Rsvp response) {
        rsvpBinder.setModel(response);
        hasChanges = false;
      }
    }).getInvitation(id);

    ValueChangeHandler dirtyStateHandler = new ValueChangeHandler() {
      @Override
      public void onValueChange(ValueChangeEvent event) {
        hasChanges = true;
      }
    };

    inviteeName.addValueChangeHandler(dirtyStateHandler); // <2>
    numberOfGuests.addValueChangeHandler(dirtyStateHandler);
    comments.addValueChangeHandler(dirtyStateHandler);

    panel.add(new Label("Name:")); // <3>
    panel.add(inviteeName);

    panel.add(new Label("Number of Guests:"));
    panel.add(numberOfGuests);

    panel.add(new Label("Comments:"));
    panel.add(comments);

    panel.add(save);

    save.addClickHandler(new ClickHandler() { // <4>
      @Override
      public void onClick(ClickEvent event) {
        invitationService.call(new ResponseCallback() {
          @Override
          public void callback(Response response) {
            hasChanges = false;
          }
        }).saveResponse(rsvpBinder.getModel());
      }
    });
  }

  @WorkbenchPartTitle
  public String getPartTitle() {
    return "RSVP (Plain Widgets)";
  }

  @WorkbenchPartView
  public Panel getView() {
    return panel;
  }

  @OnMayClose
  public boolean mayClose() {
    if (hasChanges) {
      return Window.confirm("Changes to your RSVP have not been saved.\n"
                            + "Close without saving?");
    }
    return true;
  }
}
----
<1> We can still use Errai Data Binding even without Errai
  UI. Naturally, this is up to you: you can always manage the
  model/view data binding with handwritten code too. We will see this
  approach in the MVP example that follows.
<2> We are registering the listener that handles the `hasChanges` flag
  programmatically here. Contrast with Errai UI where we used the
  `@EventHandler` annotation to register a key event handler on all
  widgets simultaneously.
<3> Similary, we build up the structure of the UI using a series of
  `panel.add()` calls. In the Errai UI example, the HTML file defined
  this structure in a way that we could instantly preview in a web
  browser just by opening the file.
<4> We register the click handler on the button programmatically.

===== Implementing Parts That Follow the MVP Pattern

The MVP (Model, View, Presenter) pattern is a variant of the more
widely known MVC (Model, View, Controller) pattern. MVP is especially
popular among GWT developers, perhaps because it has been
link:http://www.gwtproject.org/articles/mvp-architecture.html[explained
and recommended in the GWT documentation] as a good way to structure
projects and increase the proportion of fast-running unit tests to
slower GWTTestCases.

The main tenets of MVP are:

1. Model classes do not know about the Presenters or the
Views. This is the same idea as Models in MVC.
2. Presenter classes can access Model classes directly.
3. Presenter classes only talk to Views indirectly, through a View interface
the Presenters define themselves.
4. Presenter classes never reference view-level technologies (in the
case of GWT, this means no use of Widgets, DOM Elements, CSS classes,
or anything that ultimately relies on JSNI code).
5. View classes _do not_ know about Model classes. Instead, they deal
in basic data types such as String, Integer, and Date.
6. In some variants of MVP, a View may call directly into its own
Presenter to inform it of events like user input; in other variants of
MVP, this is not allowed, and the View interface includes a method for
registering generic listeners for such events. UberFire supports the
variant where the View is permitted to call directly into its Presenter.

You will see these rules in action in the following example. For a
more thorough treatment of MVP, take a look at
link:http://www.gwtproject.org/articles/mvp-architecture.html[the
original article in the GWT documentation].

These days, there is another viable option to testing GWT apps without
heavy reliance on GWTTestCase:
link:https://github.com/google/gwtmockito[GwtMockito].  GwtMockito
stubs out GWT.create() and most of the built-in GWT widget
implementations, which allows you to write fast-running JUnit tests
without the overhead of extra view interfaces and without maintaining
strict Presenter/View separation.

Nevertheless, you may well decide the benefits of MVP exceed the cost,
and UberFire together with Errai's CDI implementation make the MVP
pattern reasonably easy to follow. Here is the MVP variant of the RSVP
form:

.RSVP Screen MVP Presenter
[code, java]
----
@Dependent
@WorkbenchScreen(identifier = "com.mycompany.uftutorial.client.InvitationRsvpPresenter")
public class InvitationRsvpPresenter {

  @Inject
  private Caller<InvitationService> invitationService;

  private Rsvp rsvp;
  private final View view;

  public interface View extends UberView<InvitationRsvpPresenter> { // <1>
    String getInviteeName();
    void setInviteeName(String inviteeName);

    int getNumberOfGuests();
    void setNumberOfGuests(int numberOfGuests);

    String getComments();
    void setComments(String comments);

    boolean confirmSave();
  }

  @Inject
  public InvitationRsvpPresenter(RsvpView view) { // <2>
    this.view = checkNotNull("view", view);
  }

  @OnStartup
  public void setup(PlaceRequest place) {
    view.init(this); // <3>
    final int id = Integer.parseInt(place.getParameter("id", "-1"));
    invitationService.call(new RemoteCallback<Rsvp>() {
      @Override
      public void callback(Rsvp response) {
        rsvp = response;
        updateViewFromModel();
      }
    }).getInvitation(id);
  }

  public void save() {
    updateModelFromView();
    invitationService.call().saveResponse(rsvp);
  }

  @WorkbenchPartTitle
  public String getPartTitle() {
    return "RSVP (MVP)";
  }

  @WorkbenchPartView
  public IsWidget getView() { // <4>
    return view;
  }

  @OnMayClose
  public boolean mayClose() {
    if (hasChanges()) {
      return view.confirmSave(); // <5>
    }
    return true;
  }

  boolean hasChanges() {
    if (rsvp == null) {
      return false;
    }

    return isDifferent(view.getInviteeName(), rsvp.getInviteeName()) // <6>
           || view.getNumberOfGuests() != rsvp.getNumberOfGuests()
           || isDifferent(view.getComments(), rsvp.getComments());
  }

  private static boolean isDifferent(String s1, String s2) {
    if (s1 == null) {
      return s2 != null && !s2.trim().isEmpty();
    }
    if (s2 == null) {
      return !s1.trim().isEmpty();
    }
    return !s1.trim().equals(s2.trim());
  }

  void updateViewFromModel() { // <7>
    view.setInviteeName(rsvp.getInviteeName());
    view.setNumberOfGuests(rsvp.getNumberOfGuests());
    view.setComments(rsvp.getComments());
  }

  void updateModelFromView() { // <7>
    rsvp.setInviteeName(view.getInviteeName());
    rsvp.setNumberOfGuests(view.getNumberOfGuests());
    rsvp.setComments(view.getComments());
  }
}
----
<1> The Presenter defines all the actions it needs to perform in the
    user interface. Typically this interface is simply called `View`
    and it's nested inside the presenter. In the case of UberFire, the
    View interface extends `UberView<P>` which in turn extends GWT's
    `IsWidget` interface.
<2> In UberFire apps, the view is typically injected into the
    constructor. This makes it straightforward to unit test with a
    mock View implementation.
<3> The Presenter passes a reference to itself to its view. This
    allows the view to call back into the presenter when user
    interface events happen.
<4> Here we take advantage of the fact that `UberView` extends
    `IsWidget`, GWT's built-in interface that lets you talk about
    Widgets without actually handling one.
<5> Instead of showing the confirm dialog (which leads to JSNI code,
    something the Presenter cannot do), we ask the view to do so.
<6> In this example, we are checking for changes a little
    differently. We could have had the view call back into the
    Presenter on any Widget change to mark it dirty, but the name of
    the game in MVP is "keep the view simple!" So we're instead
    reusing a view capability that we already need (retrieving the
    current values from its widgets) and comparing with the model
    value. Remember, unless you get GwtMockito involved, everything
    you do in the View implementation will not be tested in your
    "fast" unit test suite. And if you _do_ get GwtMockito involved,
    what's the point in separating View and Presenter in the first
    place?
<7> This is the logic that Errai Data Binding will automatically
    generate for you if you can put the model instance in the same
    class as the widgets.


.RSVP Screen MVP View
[source, java]
----
@Dependent // <1>
public class InvitationRsvpView implements InvitationRsvpPresenter.View { // <2>

  private InvitationRsvpPresenter presenter;

  private final VerticalPanel panel = new VerticalPanel();
  private final TextBox inviteeName = new TextBox();
  private final ValueListBox<Integer> numberOfGuests = new ValueListBox<Integer>(IntegerRenderer.instance());
  private final TextArea comments = new TextArea();
  private final Button save = new Button("Save");

  @PostConstruct
  private void setupUi() {
    numberOfGuests.setAcceptableValues(Arrays.asList(1, 2, 3, 4));

    panel.add(new Label("Name:")); // <3>
    panel.add(inviteeName);

    panel.add(new Label("Number of Guests:"));
    panel.add(numberOfGuests);

    panel.add(new Label("Comments:"));
    panel.add(comments);

    panel.add(save);
    save.addClickHandler(new ClickHandler() {
      @Override
      public void onClick(ClickEvent event) {
        presenter.save();
      }
    });
  }

  @Override
  public void init(InvitationRsvpPresenter presenter) { // <4>
    this.presenter = checkNotNull("presenter", presenter);
  }

  @Override
  public Widget asWidget() { // <5>
    return panel;
  }

  @Override
  public String getInviteeName() {
    return inviteeName.getText();
  }

  @Override
  public void setInviteeName(String inviteeName) {
    this.inviteeName.setText(inviteeName);
  }

  @Override
  public int getNumberOfGuests() {
    return numberOfGuests.getValue();
  }

  @Override
  public void setNumberOfGuests(int numberOfGuests) {
    this.numberOfGuests.setValue(numberOfGuests);
  }

  @Override
  public String getComments() {
    return comments.getText();
  }

  @Override
  public void setComments(String comments) {
    this.comments.setText(comments);
  }

  @Override
  public boolean confirmSave() { // <6>
    return Window.confirm("Changes to your RSVP have not been saved.\n"
            + "Close without saving?");
  }
}
----
<1> In UberFire MVP, a View is a Dependent-scoped CDI bean.
<2> The View's main job is to implement the interface defined by its
  Presenter. Since it will not be unit tested, it should strive to do this as
  straightforwardly as possible. Notice that every method in this
  class except the `@PostConstruct` method is annotated with
  `@Override`. This is a good indication that the view is not doing too much.
<3> In this example, we are building the view programmatically. If we
  were using an Errai UI template, we would not need this logic in the
  view.
<4> `init()` is defined by `UberView`, and is called by the presenter
  when it's starting up.
<5> `asWidget()` is defined by `IsWidget`, which `UberView`
  extends. If your view type extends a GWT Widget type (for example,
  Errai UI views will extend `Composite`) then you'll inherit this
  method and there is no need to override it. In this example, we
  build a panel ourselves and return it here.
<6> The same confirmation code as the other examples now gets its own
  interface method so the presenter can invoke it when needed. As a
  reminder, `Window.confirm()` is being used here for
  simplicity. UberFire has a richer popup system that will be covered
  in a later section.


===== Creating Screen and Editor UIs: Conclusion

Most of your development time, and most of your users attention, will
be focused on creating the contents of your Screen and Editor
activities. UberFire gives you great flexibility in how you construct the user
interface. The examples in this section have shown some of the most
common combinations, but many other combinations are possible. You may
choose to do MVP with a view driven by Errai UI, or a monolithic view
that uses programmatic layout and Errai Data Binding, and so on.

Take some time to experiment (make sure some of that time is spent
writing tests so you get a feel for the testability of the different
approaches!), and find the approach that suits you and your team best.


==== Workbench Panels and Perspectives

No matter how you choose to create your view, it needs to be put into
a Panel before it can be displayed in the UberFire workbench. Panels
can be nested in one another, and ultimately there is a _root panel_
at the top of the panel tree. The root panel belongs to a Perspective.

A Perspective's job is threefold:

1. to define the default nesting and sizes of panels within the root
panel and further down the tree;
2. to define which workbench parts (Screens and Editors) will appear
in each panel by default;
3. to be a uniquely named anchor for saving and restoring end-user
customizations to the panels and parts in the layout

.A Perspective With Two Panels
image:example_perspective.png[A Perspective With Two Panels]

As with Screens and Editors, you have three main choices about how to
define a perspective: you can use the `@WorkbenchPerspective`
annotation, implement `WorkbenchPerspectiveActivity` directly or by
extending `AbstractWorkbenchPerspectiveActivity`, or define it as a
JavaScript extension.

Let's look at three ways to create the perspective in the example
image above.

.Example Perspective Defined Using Annotations
[code, java]
----
@Dependent // <1>
@WorkbenchPerspective(
        identifier = "HomePerspective", // <2>
        isDefault = true) // <3>
public class HomePerspective {

  @Perspective // <4>
  public PerspectiveDefinition getPerspective() {
    final PerspectiveDefinition p = new PerspectiveDefinitionImpl(MultiTabWorkbenchPanelPresenter.class.getName());
    p.setName(getClass().getName());

    p.getRoot().addPart(HelloWorldScreen.class.getName());

    PanelDefinitionImpl westPanel = new PanelDefinitionImpl(MultiListWorkbenchPanelPresenter.class.getName());
    p.getRoot().insertChild(CompassPosition.WEST, westPanel);
    westPanel.setWidth(250);
    westPanel.addPart(MoodScreen.class.getName());

    return p;
  }
}
----
<1> A Perspective is a Dependent-scoped CDI bean.
<2> Each perspective needs a unique identifier. This identifier is
  used in PlaceRequest objects that refer to the perspective, and as a
  key for saving and retrieving the customized perspective definition.
<3> Every application needs exactly one default perspective. This
  perspective is shown when the UberFire Workbench starts up.
<4>

Perspectives also participate in the `@OnStartup`, `@OnOpen`,
`@OnClose`, `@OnShutdown` lifecycle 

==== Popups and Splash Screens

==== Toolbars

==== Top-Level Menus

==== Context Menus

==== Customizing the Overall Layout

=== Uniform Lifecycle

=== Extending the Workbench

==== Defining New Panel Types


== UberFire Security

=== Authentication

=== Authorization

=== Declaring Required Permissions

==== Using Annotations

==== From Direct Implementations

==== On JavaScript Components


== UberFire VFS

=== Using From Client Side Code

=== Using From Server Side Code

=== jGit Backend

=== NIO2 Backend


== Deploying UberFire Apps

=== Full Client and Server

==== Defining The System Repository

==== Setting Up Authentication

==== Clustered Deployments

=== Standalone Client (No Server-Side Services)


== UberFire Core

* Workbench
+
Top level container for toolbars, menu bars and perspectives.
* Perspectives
+
Child of the Workbench. Group and layout panels in a composite container.
* Panels
+
Child of a perspective and a container for Parts. Different types of panel can have different behaviours, for example (as provided by default):

** Single (active) part rendered, selection of other parts using tabs. Supports drag and drop repositioning of parts.
** Single (active) part rendered, selection of other parts from a drop-down listbox. Supports drag and drop repositioning of parts.
** Single part; fixed content. Drag and drop support disabled.
* Parts
+
Child of a Panel. A Part is the finest grained logical entity within the Workbench. A Part is represented by a Place and can be a Screen or an Editor.
* Place
+
Everything within the Uberfire framework is considered to be a Place; and can be launched programmatically. All places should have a unique identifier within the Workbench.
* PlaceRequest
+
A request for the Workbench to go to a Place. PlaceRequests can represent a perspective, pop-up, screen or editor.
* Path
+
A Path is a location within any Virtual File System configured within UberFire. Editors can be defined to respond to different Paths.
* ObservablePath
+
An ObservablePath is an extension of a Path that provides a mechanism to listen to Path's changes, the list of possible changes are Rename, Delete, Update or Copy.
* Screens
+
A screen is not associated to a Path pattern and can be launched by requesting the corresponding Place. Screens can be used for static content; or for resources beyond UberFire's VFS mechanisms. 
* Editors
+
An editor is associated to a Path pattern. Requests for Places that correspond to a Path will launch corresponding editor. Editors can be used for resources within UberFire's VFS mechanisms.
* Splash Screens
+
A splash screen is an informative screen that can be displayed when any Place is displayed (due an interception process). A splash screen may have multiple interception points.
* Contexts
+
A context can be any widget and the most common use case is to provide context navigation. An example of context navigation is an Editor that uses context to provide a
file browser pointing to current file directory. Although context navigation is the most common usage, Context can be used to other purposes like display Part's metadata
or even a chat widget.
* Menus
+
UberFire Menus aims to provide a common abstraction to define general purpose menus.

** Menu Item
+
Top level abstraction that provides common menu item metadata like a caption, state (enabled or disabled), position (left, right, center) and order.
** Menu Group
+
An specialized Menu Item that groups other menu items.
** Menu Custom
+
An specialized Menu Item that users can provide it's own custom menu item. Most flexible, but non portable, way to define a menu item user interface.
* Tool bars
+
Common abstraction to define a Tool bar. Due the graphic interface nature of a Tool bar, tool bar items are not only associated with an action but also with an icon.
* Principal
+
A principal is just a security term for an identifying attribute, such as a username or user id or social security number or anything else that can be considered an 'identifying' attribute for a Subject.
* Role
+
A Roles represents a permission. An Identity may have multiple roles.
* Subject & Identity
+
Subject or Identity is any entity that represents the authenticated user (that can be a user account, a computer account, or a thread or process). Although the term Subject is common for
most security related frameworks, we believe that this word is a bit vague and due this reason in UberFire the term Identity is used instead of Subject.
* SessionInfo
+
SessionInfo is the abstraction that aims to represent an unique pair of Identity and session id. Differently from traditional Java web applications where sessions are browser based, UberFire session id's
are unique on browser tab level. This is the type that is used by ObservablePath to identify external changes.
* Resources
+
Resource is a marker interface used for access restriction purposes (security).
* Types
** ResourceTypeDefinition
+
A portable model which represents a resource type (resource in this context means a type of a Path and it's not related to security resource).
* NotificationEvent
+
Signal a informative notification (e.g. "File saved" etc) that appears within the Workbench as a popup message. Raised by whoever needs to inform users of a notification. There are four types of notifications: DEFAULT, ERROR, SUCCESS, INFO and WARNING.
* VFS Events
** ResourceAddedEvent
+
Signal a resource has been added to a VFS. Raised by VFS.
** ResourceBatchChangesEvent
+
Signal a batch change to various resources within a VFS. Raised by VFS.
** ResourceCopiedEvent
+
Signal a resource has been copied within a VFS. Raised by VFS.
** ResourceDeletedEvent
+
Signal a resource has been deleted from a VFS. Raised by VFS.
** ResourceOpenedEvent
+
Signal a resource has been opened (Note: Uberfire does not make raise or observe the event itself) 
** ResourceRenamedEvent
+
Signal a resource has been renamed within a VFS. Raised by VFS.
** ResourceUpdatedEvent
+
Signal a resource has been modified within a VFS. Raised by VFS.

* Widgets
+
UberFire is not a widget library and can be used with different third party libraries.


== UberFire Backend API

These concepts are expressed in the `uberfire-backend-api` module,
which defines mostly common services that are used by client side,
but implemented in the server side.

* VFS (Virtual File System)
+
The Virtual File System API provides a set of IO related features for client-side components.


== UberFire Client API

These concepts are expressed in the `uberfire-client-api` package,
which defines an API that's only accessible to client-side
(in-browser) code.

* Annotations
** Perspective
+
Marker annotation to allow a `@WorkbenchPerspective` to declare a method that returns a PerspectiveDefinition object, defining the workbench perspective.
** WorkbenchEditor
+
A marker annotation to declare a class as being a Workbench Editor. Editors relate to specific resources within the framework, defined by their ResourceTypeDefinition.
** WorkbenchPartTitle
+
A marker annotation to declare a method within a `@WorkbenchEditor` or `@WorkbenchScreen` that returns a String defining the title for the component.
** WorkbenchPartTitleDecoration
+
A marker annotation to declare a method within a `@WorkbenchEditor` or `@WorkbenchScreen` that returns an IsWidget object to be used as a decoration, beside the @WorkbenchPartTitle.
** WorkbenchPartView
+
A marker annotation to declare a method within a `@WorkbenchEditor` or `@WorkbenchScreen` that returns a IsWidget object representing the view (or user-interface) of the component.
** WorkbenchPerspective
+
Marker annotation to declare a class as providing a perspective definition. The definition itself is returned from a method within the `@WorkbenchPerspective` annotated with @Perspective. 
** WorkbenchPopup
+
Marker annotation to declare a class as being a popup that can be displayed by the framework.
** WorkbenchScreen
+
A marker annotation to declare a class as being a Workbench Screen. Screens would usually display static content, or at least content that is not dependent upon a Path within the underlying VFS. The screen could still consume external resources (e.g. query a database) however it does not integrate with the framework's use of Paths.
** DefaultPosition
+
Marker annotation to allow either `@WorkbenchEditor` 's or `@WorkbenchScreen` 's to declare a method that returns the default location of the component in a perspective when opened by the framework. NOTE: This is specific to the NSEW perspective type. Work is in progress to provide support for additional types of perspective.
** WorkbenchMenu
+
A marker annotation to declare a method within a `@WorkbenchPerspective`, `@WorkbenchEditor` or `@WorkbenchScreen` that returns a Menus object defining a menu to be shown by the framework when the perspective, editor or screen is displayed.
** WorkbenchToolbar
+
A marker annotation to declare a method within a `@WorkbenchPerspective`, `@WorkbenchEditor` or `@WorkbenchScreen` that returns a ToolBar object defining a toolbar to be shown by the framework when the perspective, editor or screen is displayed.
** WorkbenchContext
+
A marker annotation to declare a class as being a Workbench context widget.
** WorkbenchContextId
+
A marker annotation to declare a method within a `@WorkbenchEditor` or `@WorkbenchScreen` that returns a reference to a WorkbenchContext identifier.
** WorkbenchSplashScreen
+
Marker annotation to declare a class as providing a Splash Screen definition. --->The definition itself is returned from a method within the `@WorkbenchPerspective` annotated with @Perspective.
** Intercept
+
A marker annotation to declare a method within a `@WorkbenchSplashScreen` that returns a boolean that has it's own decision to intercept or not a Place.
** SplashBodyHeight
+
In order to have a proper render, a splash screen needs to provide the height of it's body.
** SplashFilter
+
A marker annotation to declare a method within a `@WorkbenchSplashScreen` that returns a SplashScreenFilter used to check if a Place should be intercepted ot not.

* Interfaces
** UberView
+
A convenience interface to support linking a View to it's Presenter as required by implementations of the MVP pattern. Uberfire itself does not impose use of MVP.

* Events
** ChangeTitleWidgetEvent
+
A CDI event that provides support for `@WorkbenchEditor` 's and @Workbench screens to inform the framework that their title or decoration should be updated.
** NewSplashScreenActiveEvent
+
Signal when one or more splash screens is available in the current navigation (during an interception of a Perspective or a Part).
* Types
** ClientResourceType
+
Extends ResourceTypeDefinition with client-side specific information like icon representation; allowing `@WorkbenchEditor` 's to specify the types of resource they are capable of handling.

* UberFire Preferences
+
Utility class that holds general preferences that have impact in UberFire client behavior. Those preferences should be setted by application EntryPoint, in order to be sure that
it will take place before Workbench starts up. Here are the existing preferences that can be set:

** org.uberfire.client.workbench.clone.ou.mandatory.disable: disable the mandatory OU field of new repositories.
** org.uberfire.client.workbench.widgets.listbar.context.disable: disables `Context` behavior.
** org.uberfire.client.workbench.path.automatic.close.onDelete: disables the automatic close of an `Editor` if the file is deleted.


== UberFire Commons

These concepts are expressed in the `uberfire-commons` package,
which contains a mix of server-only definitions shared client/server definitions.

* Data
 ** Pair, a generic 2-tuple (client + server)
 ** Triple, a generic 3-tuple (client + server)
 ** Cacheable, interface that provides explicit visibility of cached data.
* Lock Service (server-only)
+
Common service interface to implement locks. Provides a `Thead` default implementation.
* Clustering (server-only, see also UberFire I/O)
+
A general clustering abstraction that provides a combination of `Lock` and `Message` services in a clustered environment (multiple computers).
* Messaging
+
General purpose messaging abstraction (server-only, distinct from Errai Bus messages). Currently implemented by IO clustered setup.

** Message
+
Message is basically a composition of a `MessageType` and a `Map` of arbitrary values.
** AsyncCallback
+
Async callback mechanism used to by call and wait messaging broadcast. Currently used to sync file systems in the cluster during startup.
** MessageHandler
+
Interface that process messages, messages are routed to MessageHandler by `MessageHandlerResolver`.
** MessageHandlerResolver
+
Simple routing mechanism to `MessageHandler` 's.
** MessageService
+
Common service interface to implement broadcast (sync/async) and participant specific messaging exchange.
** MessageType
+
Simple message classification. Usually used by `MessageHandlerResolver` in order to route a message to a proper `MessageHandler`.

* CDI Startup Beans (the @Startup annotation) (server-only)
* PortablePreconditions (client + server), a collection of static methods for checking common preconditions (reference not null, list not empty, etc.)
** Note: Errai has a shared class called Assert which serves a similar purpose
* Preconditions (server-only), precondition checks that are not GWT-translatable


== UberFire I/O

These concepts are expressed in the `uberfire-io` package,
which contains server-only code.

* IOService
+
IOService is the UberFire specific abstraction for all IO related operations. This abstraction is important to anble UberFire provide
additional features on top of IO operations (e.g. transparent indexing of content).

** IOServiceNio2Wrapper
+
Simplest IOService implementation that just wrappers NIO2 backported api.
** IOServiceDotFile
+
This implementation stores every non link:http://docs.oracle.com/javase/7/docs/api/java/nio/file/attribute/BasicFileAttributes.html[basic file attribute] in dot file.
This feature enables users associate any meta information to a `Path`.
** Clustered Service
+
Clustered `IOService` implementation that wrappers another `IOService` and uses UberFire Clustering service to manage a global 'Lock' and `FileSystem` sync.
* Watch Service
+
Provides a high level service implementation to convert link:http://docs.oracle.com/javase/tutorial/essential/io/notification.html[IO notifications] to the following CDI events:
`ResourceAddedEvent`, `ResourceDeletedEvent`, `ResourceRenamedEvent`, `ResourceUpdatedEvent` and  `ResourceBatchChangesEvent`.

* Search Service
+
Provides search capabilities (full text and attribute based searching) over `FileSystem` 's.
* Attributes
+
Attributes represents `FileSystem` metadata, for more information check link:http://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html[NIO2 docs].

** Dublin Core (TM) metadata
+
UberFire implementation of link:http://dublincore.org[Dublin Core (TM)] metadata using `FileSystem` attributes.


== UberFire JS

These concepts are expressed in the `uberfire-js` package, which
exposes a JavaScript API for some aspects of the UberFire framework.
This gives application developers the option to write UberFire
applications partly or entirely in JavaScript.

* JavaScript native plugin, with types representing
** Perspectives
** Plugins
** Workbench perspective activities
** Workbench screen activities
** Panel definitions
** Part definitions


== UberFire NIO2

The `uberfire-nio2-backport` module includes a backport of the Java SE
7 "new new IO" APIs to Java SE 6. The backport is repackaged under the
org.uberfire.java.nio.* namespace. It also provides a couple of utility
classes in the `org.apache.commons.io` package.

The UberFire NIO2 API is only intended for use on the server side.

UberFire includes NIO2 FileSystem implementations for the plain
filesystem, for git repositories (via jgit), and for the Eclipse
virtual filesystem.


== UberFire Server

These concepts are expressed in the `uberfire-server` package,
which contains some server-side functionality.

* UberFire Servlet
** App template, header template, footer template, user data template
* FileUpload Servlet
+
Servlet that provides file upload capabilities for binary related `Editor` 's.
* FileDownload Servlet
+
Servlet that provides file download capabilities for binary related `Editor` 's.


== UberFire Workbench

These concepts are expressed in the `uberfire-workbench` package,
which provides annotation processors for the core annotations in
`uberfire-client-api`. 

UberFire supports re-use or authoring of any widgets however promotes use of the MVP (Model, View, Presenter) design 
pattern. Both `@WorkbenchScreen` 's and `@WorkbenchEditor` 's need only declare a minimal number of "hooks" to UberFire. 
Legacy widgets too can be simply wrapped to work within UberFire.  

* The Workbench physical hierarchy (top to bottom): 
** User application
** UberFire Workbench
** UberFire `@WorkbenchPerspective`
** UbefFire `@WorkbenchScreen` or `@WorkbenchEditor`

* The Workbench logical hierachy (top to bottom):
** User application
** Workbench
** Perspective
** Panel
** Part

* The Workbench logical-to-physical mapping (top to bottom):
** Perspective -> `@WorkbenchPerspective`
** Part -> `@WorkbenchScreen` or `@WorkbenchEditor`

* The Workbench relationships:
** Workbench -> [1..n] -> Perspective -> [1..n] -> Panel -> [1..n] -> Part

* Annotation processors for:
** `@WorkbenchPerspective`
** `@WorkbenchContext`
** `@WorkbenchEditor`
** `@WorkbenchScreen`
** `@WorkbenchPopup`

* GWT Bootstrap and UberFireConfigurator
** FontAwesome resources

* The UberFire MVP framework
** Places
+
Every `@WorkbenchPerspective`, `@WorkbenchScreen`, `@WorkbenchEditor` and `@WorkbenchPopup` is represented 
by a `Place`. In order to display a `Place` developers need tell UberFire to "goto" a `Place`. UberFire
provides a `PlaceManager` that can be injected into your own code and used to programmatically navigate 
to any `Place` you require.

*** Place Requests
+
A request for UberFire to navigate to a place.

**** DefaultPlaceRequest
+
A request to navigate to a `@WorkbenchPerspective`, `@WorkbenchScreen` or a `@WorkbenchPopup`. These do not require 
knowledge of the `Path` they represent as the logical identifier of the foregoing physical entity is used to
lookup a corresponding entity.

**** PathPlaceRequest
+
A request to navigate to a `@WorkbenchEditor` that is registered to handle the specified Path.

** Activities
+
Internally every class annotated with either `@WorkbenchPerspective`, `@WorkbenchScreen`, `@WorkbenchEditor` or `@WorkbenchPopup`
has a corresponding wrapper class generated by UberFire's annotation processor. These classes are called `Activities`. Every
`Activity` is a subclass of an internal UberFire classes that plugs into UberFire's life-cycle management.
+
Consquentially every `@WorkbenchPerspective`, `@WorkbenchScreen`, `@WorkbenchEditor` or `@WorkbenchPopup` can register
"hooks" for UberFire to invoke corresponding to it's life-cycle.

*** `@WorkbenchPerspective` lifecycles
**** `@OnStartup`
+
Executed when a request to "go to" a component is received, but prior to it being displayed by the framework.
This gives the component an opportunity to perform any initialization work.
**** `@OnOpen`
+
Executed when the component is displayed.
**** `@OnClose`
+
Executed when the component is being hidden, i.e. before "going to" another Perspective.
**** `@OnShutdown`
+
Executed after the component is closed, giving it an opportunity to release resources or perform any tidy-up operations.

*** `@WorkbenchScreen` lifecycles
**** `@OnStartup`
+
Executed when a request to "go to" a component is received, but prior to it being displayed by the framework.
This gives the component an opportunity to perform any initialization work.
**** `@OnOpen`
+
Executed when the component is displayed.
**** `@OnFocus`
+
Executed when an existing "open" component receives the focus from either the user or when the `Part` has been displayed.
**** `@OnLostFocus`
+
Executed when an existing "open" component looses the focus by another `Part` receiving the focus.
**** `@OnMayClose`
+
Executed prior to the `Part` being closed by the framework. This gives the component an opportunity to veto closure, 
for example should it contain data that may need persisting. The default is for the framework to close the `Part` automatically.
**** `@OnClose`
+
Executed when the component is being closed normally in response to the user clicking the "close" icon for the `Part`.
**** `@OnShutdown`
+
Executed after the component is closed, giving it an opportunity to release resources or perform any tidy-up operations.

*** `@WorkbenchEditor` lifecycles
**** `@OnStartup`
+
Executed when a request to "go to" a component is received, but prior to it being displayed by the framework.
This gives the component an opportunity to perform any initialization work.
**** `@OnOpen`
+
Executed when the component is displayed.
**** `@OnFocus`
+
Executed when an existing "open" component receives the focus from either the user or when the `Part` has been displayed.
**** `@OnLostFocus`
+
Executed when an existing "open" component looses the focus by another `Part` receiving the focus.
**** `@IsDirty`
+
Used to check if the current editor has a dirty state (some data has changed) or not. Usually this method is used by `@OnMayClose`.
**** `@OnSave`
+
Executed when a `SavePlaceEvent` is raised corresponding to the `Part`.
**** `@OnMayClose`
+
Executed prior to the `Part` being closed by the framework. This gives the component an opportunity to veto closure, 
for example should it contain data that may need persisting. The default is for the framework to close the `Part` automatically.
**** `@OnClose`
+
Executed when the component is being closed normally in response to the user clicking the "close" icon for the `Part`.
**** `@OnShutdown`
+
Executed after the component is closed, giving it an opportunity to release resources or perform any tidy-up operations.

*** `@WorkbenchPopup` lifecycles
**** `@OnStartup`
+
Executed when a request to "go to" a component is received, but prior to it being displayed by the framework.
This gives the component an opportunity to perform any initialization work.
**** `@OnOpen`
+
Executed when the component is displayed.
**** `@OnMayClose`
**** `@OnClose`
+
Executed when the component is being closed normally in response to the user clicking the "close" icon for the `Part`.
**** `@OnShutdown`
+
Executed after the component is closed, giving it an opportunity to release resources or perform any tidy-up operations.

*** `@WorkbenchContext` lifecycles
**** `@OnContextAttach`
+
Executed when the `Context` is attached to it's `Part` in a Panel.

** Panels and Layouts
+
UberFire ships with a single "Window Manager" that is responsible for the layout and operation of the `Workbench`.
The default implementation has the concept of `Panel` 's laid out according to the points of a compass; i.e.
North, South, East and West. The "Window Manager" also supports re-positioning of `Part` 's by dragging them
to new locations.
+
`Panel` 's can be of different types: 

*** Multi Tab Workbench Panels
+
Panel that supports multiple `Part` 's displayed using a Tab widget. Selection of other parts using tabs. Supports drag and drop repositioning of parts.
*** Multi List Workbench Panels
+
Panel  that supports multiple `Part` 's displayed in custom widget that display `Part` 's context menus. Selection of other parts from a drop-down listbox. Supports drag and drop repositioning of parts.
*** Simple Workbench Panels
+
Panel that supports a single `Part` displayed in a custom widget that display `Part` 's context menus. Drag and drop disabled by default, but can be activated.
*** Static Workbench Panels
+
Simplest possible panel that supports a single `Part`. No drag and drop support.

** Headers
+
`Header` 's represent horizontal sections of the Workbench that can contain arbritrary content.
They are included automatically above the Workbench user-space ordered according to their definition.
For example a `Header` could be defined to hold a top-level Menu defintion and another `Header`
could be defined to hold a top-level Toolbar definition.

** Footers
+
`Footer` 's represent horizontal sections of the Workbench that can contain arbritrary content.
They are included automatically under the Workbench user-space ordered according to their definition.
For example a `Footer` could be defined to hold a copyright information.

** The Workbench Menu Bar
+
UberFire supports context sensitive Menus. Menus can be defined at different levels:

*** Workbench
+
Developers can place a `WorkbenchMenuBarPresenter` into a `Header` to provide a top-level Menu for the whole Workbench. 
*** `@WorkbenchPerspective`
+
Perspectives can annotate a method with `@WorkbenchMenu` to declare a method that returns a `Menu` definition. 
UberFire will show the menu definition automatically whenever the Perspective is displayed.
*** `@WorkbenchScreen` or `@WorkbenchEditor`
+
Static screens and Editors can annotate a method with `@WorkbenchMenu` to declare a method that returns a `Menu` definition. 
UberFire will show the menu definition automatically whenever the screen receives the focus.

** The Workbench Tool Bar
+
UberFire supports context sensitive Toolbars. Toolbars can be defined at different levels:

*** Workbench
+
Developers can place a `WorkbenchToolBarPresenter` into a `Header` to provide a top-level Toolbar for the whole Workbench. 
*** `@WorkbenchPerspective`
+
Perspectives can annotate a method with `@WorkbenchToolbar` to declare a method that returns a `ToolBar` definition. 
UberFire will show the toolbar definition automatically whenever the Perspective is displayed.
*** `@WorkbenchScreen` or `@WorkbenchEditor`
+
Static screens and Editors can annotate a method with `@WorkbenchToolbar` to declare a method that returns a `ToolBar` definition. 
UberFire will show the toolbar definition automatically whenever the screen receives the focus.

* Workbench Events
** ApplicationReadyEvent
+
Signal when certain resources have been injected into the GWT Host Page and other bootstrap processes complete. Raised by UberFire.
** BeforeClosePlaceEvent
+
Signal when a Part is about to be closed; normally in response to the user electing to interactively close a Part. Screens and Editors can veto the closure (for example if they contain unsaved content). Raised by Uberfire.
** ClosePlaceEvent
+
Signal when a Part is closed. This event signals the removal of a Part from a Panel. Raised by Uberfire.
** DropPlaceEvent
+
Part of the drag and drop support. Signals a Part has been dragged to and dropped on a target Panel. Raised by Uberfire.
** MaximizePlaceEvent
+
Signals a Part has been "maximized" to consume the whole Workbench client region (Note: Work in progress). Raised by Uberfire.
** NewPerspectiveEvent
+
Signal that a new `Perspective` was registered during runtime. Raised by Uberfire (related to `uberfire-js` module).
** NewWorkbenchScreenEvent
+
Signal that a new `Screen` was registered during runtime. Raised by Uberfire (related to `uberfire-js` module).
** PanelFocusEvent
+
Signal a Panel has received the input focus. Raised by Uberfire.
** PerspectiveChange
+
Signal a change in active Perspective. Raised by Uberfire.
** PlaceGainFocusEvent
+
Signal a Place has gained the input focus. Raised by Uberfire.
** PlaceLostFocusEvent
+
Signal a Place has lost the input focus. Raised by Uberfire.
** SavePlaceEvent
+
Signal an Editor can have it's state saved. Raised by developers using Uberfire from Widgets outside of the Editor itself (e.g. a Workbench Menubar entry).
** SelectPlaceEvent
+
Signal a Place has been selected. Raised by Uberfire.


== UberFire Security

These concepts are expressed in the `uberfire-security-api` package,
and they are all available to both client- and server-side code.

* Security interceptor annotations (for types and methods)
** `@All`
** `@Authorized`
** `@Deny`
** `@Roles({})`
* Authenticated Storage
* Role
* Authorization Manager
* Decision Managers:
** Resource Decision Manager
** Role Decision Manager
* Roles Resource
* Runtime Resource
* Voting Strategy
* Crypt Provider
* Resource
* Resource Manager
* Security Context
* Security Manager

Plus some new concepts:

* URL Resource
* Ant Paths
