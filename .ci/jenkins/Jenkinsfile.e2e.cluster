@Library('jenkins-pipeline-shared-libraries')_

helper = null

minikubeClusterPlatform = 'minikube'
openshiftClusterPlatform = 'openshift'

pipeline {
    agent {
        label "${env.AGENT_LABEL ?: "rhel8"} && podman && !built-in"
    }

    options {
        timeout(time: 3, unit: 'HOURS')
        timestamps()
    }

    tools {
        go 'golang-1.19'
    }

    environment {
        // Linked to node label
        CONTAINER_ENGINE='podman'
        CONTAINER_ENGINE_TLS_OPTIONS='--tls-verify=false'
    }

    stages {
        stage('Setup pipeline') {
            steps {
                script {
                    helper = load '.ci/jenkins/scripts/helper.groovy'
                    helper.initPipeline()
                }
            }
        }
        stage('Initialize') {
            steps {
                script {
                    clean()

                    helper.updateDisplayName()
                    helper.checkoutRepo()

                    assert getTestImage(): 'Please provide a Test image'
                    container.pullImage(getTestImage()) // Verify image exists
                }
            }
        }
        stage('Setup cluster') {
            steps {
                script {
                    setupCluster()
                }
            }
        }
        stage('Prepare for e2e tests') {
            when {
                expression { 
                    return helper.shouldLaunchTests() && helper.isRelease() 
                }
            }
            steps {
                script {
                    // Define specific tests images as those to override defaults
                    // Because released builder and devmode images are not yet available
                    String platformCRFilepath = getPlatformCRFilePath()
                    String[] versionSplit = getOperatorVersion().split("\\.")
                    String majorMinor = "${versionSplit[0]}.${versionSplit[1]}"
                    def platformCR = readYaml(file: platformCRFilepath)

                    platformCR.spec.devMode = platformCR.spec.devMode ?: [:]
                    platformCR.spec.devMode.baseImage = "quay.io/kiegroup/kogito-swf-devmode-nightly:${majorMinor}"

                    platformCR.spec.build = platformCR.spec.build ?: [:]
                    platformCR.spec.build.config = platformCR.spec.build.config ?: [:]
                    platformCR.spec.build.config.baseImage = "quay.io/kiegroup/kogito-swf-builder-nightly:${majorMinor}"
                    writeYaml(file: platformCRFilepath, data: platformCR, overwrite: true)
                }
            }
        }
        stage('Run e2e tests') {
            steps {
                script {
                    executeInCluster {
                        try {
                            sh """
                                export CLUSTER_PLATFORM=${getClusterName()}
                                export OPERATOR_IMAGE_NAME=${getTestImage()}
                                make test-e2e
                            """
                        } catch (err) {
                            sh 'make undeploy'
                            throw err
                        }
                        sh 'kubectl get pods -A'
                    }
                }
            }
        }
    }
    post {
        cleanup {
            script {
                clean()
            }
        }
    }
}

void clean() {
    helper.cleanGoPath()
    util.cleanNode(containerEngine)
    cleanupCluster()
}

String getTestImage() {
    return params.TEST_IMAGE_FULL_TAG
}

String getClusterName() {
    return env.CLUSTER_NAME
}

String getOperatorVersion() {
    return sh(script: 'source ./hack/env.sh > /dev/null && echo $(getOperatorVersion)', returnStdout: true).trim()
}

void setupCluster() {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            setupMinikube()
            break
        case openshiftClusterPlatform:
            setupOpenshift()
            break
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot prepare for it ..."
    }
}

void setupMinikube() {
    // Start minikube
    minikube.minikubeMemory = '12g'
    minikube.start()

    minikube.waitForMinikubeStarted()
    minikube.waitForMinikubeRegistry()
}

void setupOpenshift() {
    // Login to Openshift
    openshift.loginOpenshift()
}

void cleanupCluster() {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            minikube.stop()
            break
        case openshiftClusterPlatform:
            echo 'Nothing to cleanup on openshift. All good !'
            break
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot cleanup ..."
    }
}

void executeInCluster(Closure executeClosure) {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            echo "Execute in minikube"
            executeClosure()
            break
        case openshiftClusterPlatform:
            echo "Execute in openshift"
            lock("Sonataflow Operator OpenShift tests ${getOpenshiftApi()}") {
                executeClosure()
            }
            break
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot execute anything ..."
    }
}

void getPlatformCRFilePath() {
    switch (getClusterName()) {
        case minikubeClusterPlatform:
            return 'test/testdata/sonataflow.org_v1alpha08_sonataflowplatform_withCache_minikube.yaml'
        case openshiftClusterPlatform:
            return 'test/testdata/sonataflow.org_v1alpha08_sonataflowplatform_openshift.yaml'
        default:
            error "Unknown cluster name ${getClusterName()}. Cannot execute anything ..."
    }
}

// Special method to get the Openshift API in the lock because env is not accessible yet
void getOpenshiftApi() {
    withCredentials([string(credentialsId: env.OPENSHIFT_API_KEY, variable: 'OPENSHIFT_API')]) {
        return env.OPENSHIFT_API
    }
}
