@Library('jenkins-pipeline-shared-libraries')_

helper = null
testsFailed = false

pipeline {
    agent {
        label 'kie-rhel8 && !built-in'
    }

    tools {
        go 'golang-1.19'
    }

    options {
        timeout(time: 120, unit: 'HOURS')
        timestamps()
    }

    environment {
        KOGITO_CI_EMAIL_TO = credentials("${JENKINS_EMAIL_CREDS_ID}")
    }

    stages {
        stage('Setup pipeline') {
            steps {
                script {
                    helper = load '.ci/jenkins/scripts/helper.groovy'
                    helper.initPipeline()
                }
            }
        }
        stage('Initialize') {
            steps {
                script {
                    helper.cleanGoPath()

                    helper.updateDisplayName()
                    helper.checkoutRepo()
                }
            }
        }

        stage('Update version') {
            steps {
                script {
                    sh "make bump-version new_version=${helper.getProjectVersion()}"
                }
            }
        }

        stage('Clean release notes') {
            when {
                expression { isMainBranch() }
            }
            steps {
                script {
                    String releaseNotesFilename = 'RELEASE_NOTES.md'
                    sh "rm -rf ${releaseNotesFilename}"
                    writeFile(file: releaseNotesFilename, text: getCleanedReleaseNotes())
                }
            }
        }

        stage('Update branch') {
            steps {
                script {
                    sh '''
                        git checkout -- go.mod
                        git checkout -- go.sum
                    '''
                    if (githubscm.isThereAnyChanges()) {
                        githubscm.commitChanges("[${helper.getBuildBranch()}] Update version to ${helper.getProjectVersion()}", {
                            sh '''
                                git add .
                            '''
                        })
                        githubscm.pushObject('origin', helper.getBuildBranch(), helper.getGitAuthorCredsID())
                    } else {
                        println '[WARN] no changes to commit'
                    }
                }
            }
        }

        stage('Build Kogito Operator') {
            steps {
                sh "make container-build BUILDER=${env.CONTAINER_ENGINE}"
            }
            post {
                unsuccessful {
                    script {
                        util.archiveConsoleLog()
                    }
                }
            }
        }

        stage('Push to registry') {
            steps {
                script {
                    helper.loginRegistry()

                    container.tagImage(getBuiltImage(), helper.getImageFullTag(env.OPERATOR_IMAGE_NAME))
                    container.pushImage(helper.getImageFullTag(env.OPERATOR_IMAGE_NAME))

                    String reducedTag = helper.getReducedTag()
                    if (reducedTag) {
                        String finalFullImage = helper.getImageFullTag(env.OPERATOR_IMAGE_NAME, defaultImageParamsPrefix, reducedTag)
                        container.tagImage(getBuiltImage(), finalFullImage)
                        container.pushImage(finalFullImage)
                    }
                }
            }
        }
    }
    post {
        unsuccessful {
            sendNotification()
        }
        cleanup {
            script {
                helper.cleanGoPath()
                util.cleanNode(containerEngine)
            }
        }
    }
}

void sendNotification() {
    if (params.SEND_NOTIFICATION) {
        mailer.sendMarkdownTestSummaryNotification('Setup branch', "[${helper.getBuildBranch()}] Kogito Serverless Operator", [env.KOGITO_CI_EMAIL_TO], "You can find test error logs here: ${BUILD_URL}/artifact/test/logs/error/")
    } else {
        echo 'No notification sent per configuration'
    }
}

String getOperatorVersion() {
    return sh(script: 'source ./hack/env.sh > /dev/null && echo $(getOperatorVersion)', returnStdout: true).trim()
}

String getOperatorImageName() {
    return sh(script: 'source ./hack/env.sh > /dev/null && echo $(getOperatorImageName)', returnStdout: true).trim()
}

String getBuiltImage() {
    return "${getOperatorImageName()}:${getOperatorVersion()}"
}

boolean isMainBranch() {
    return env.IS_MAIN_BRANCH?.toBoolean()
}

String getCleanedReleaseNotes() {
    return '''
<!-- Keep them in alphabetical order -->
## Enhancements

## Bug Fixes

## Known Issues

'''
}
